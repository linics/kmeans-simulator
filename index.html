<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>K-Means 互动课件 | Phase 2 Logic</title>
<!-- ===== Styles ===== -->
<style>
  :root {
    color-scheme: light dark;
    --bg-main: #f5f6fa;
    --bg-panel: #ffffff;
    --bg-accent: #eef2ff;
    --text-primary: #1e1e2f;
    --text-secondary: #3d3d52;
    --border-color: #d0d4e4;
    --accent: #4c6ef5;
    --focus-outline: #ff922b;
    --tab-bg: #f0f3ff;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Microsoft YaHei", sans-serif;
    background: var(--bg-main);
    color: var(--text-primary);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  body:focus-visible {
    outline: none;
  }

  a {
    color: inherit;
  }

  .app-shell {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }

  header {
    background: var(--bg-panel);
    box-shadow: 0 2px 8px rgba(30, 46, 90, 0.08);
    padding: 1.2rem 1.6rem;
    position: sticky;
    top: 0;
    z-index: 10;
  }

  header h1 {
    margin: 0 0 0.4rem;
    font-size: 1.8rem;
    font-weight: 700;
  }

  .intro-text {
    margin: 0;
    font-size: 0.95rem;
    color: var(--text-secondary);
    line-height: 1.6;
  }

  .usage-banner {
    margin-top: 0.8rem;
    padding: 0.8rem 1rem;
    background: var(--bg-accent);
    border-radius: 12px;
    font-size: 0.9rem;
  }

  .top-controls {
    margin-top: 1.4rem;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 0.8rem;
  }

  .control-block {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }

  .control-block label {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-secondary);
  }

  .control-block select,
  .control-block input,
  .control-block button {
    padding: 0.45rem 0.6rem;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    background: #fff;
    font-size: 0.95rem;
    transition: border 0.2s ease, box-shadow 0.2s ease;
  }

  button.primary {
    background: var(--accent);
    color: #fff;
    border: none;
  }

  button.icon-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.4rem;
    font-weight: 600;
  }

  button:focus-visible,
  input:focus-visible,
  select:focus-visible,
  textarea:focus-visible {
    outline: 2px solid var(--focus-outline);
    outline-offset: 2px;
  }

  main {
    flex: 1;
    display: grid;
    grid-template-columns: 320px minmax(0, 1fr) 340px;
    gap: 1rem;
    padding: 1rem 1.5rem 1.5rem;
  }

  .panel {
    background: var(--bg-panel);
    border-radius: 16px;
    padding: 1rem;
    box-shadow: 0 4px 18px rgba(30, 46, 90, 0.06);
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .controls-panel {
    overflow-y: auto;
  }

  .canvas-panel {
    display: flex;
    flex-direction: column;
  }

  .canvas-wrapper {
    flex: 1;
    background: linear-gradient(135deg, rgba(76, 110, 245, 0.08), rgba(135, 206, 250, 0.12));
    border-radius: 18px;
    position: relative;
    border: 1px dashed rgba(76, 110, 245, 0.3);
  }

  canvas#cluster-canvas {
    width: 100%;
    height: 100%;
    display: block;
    border-radius: 18px;
  }

  .canvas-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    color: var(--text-secondary);
    font-size: 1rem;
    text-align: center;
    padding: 1rem;
  }

  .metrics-bar {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 0.8rem;
    margin-top: 1rem;
  }

  .metric-card {
    background: var(--tab-bg);
    padding: 0.8rem;
    border-radius: 12px;
    font-size: 0.85rem;
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }

  .metric-card strong {
    font-size: 1rem;
  }

  .tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
  }

  .tabs button {
    flex: 1;
    background: transparent;
    border: none;
    padding: 0.8rem 0.6rem;
    font-weight: 600;
    cursor: pointer;
    border-bottom: 3px solid transparent;
  }

  .tabs button.active {
    border-bottom-color: var(--accent);
    color: var(--accent);
  }

  .tab-content {
    flex: 1;
  }

  .tab-pane {
    display: none;
  }

  .tab-pane.active {
    display: block;
  }

  .tab-pane section {
    margin-bottom: 1rem;
  }

  .tab-pane h3 {
    margin: 0 0 0.6rem;
    font-size: 1.05rem;
  }

  .tab-pane p,
  .tab-pane ul,
  .tab-pane li {
    font-size: 0.92rem;
    line-height: 1.6;
  }

  .quiz-question {
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 0.9rem;
    margin-bottom: 0.8rem;
  }

  .quiz-question h4 {
    margin: 0 0 0.6rem;
    font-size: 0.98rem;
  }

  .quiz-options {
    display: grid;
    gap: 0.6rem;
  }

  footer {
    margin-top: auto;
    padding: 1rem 1.6rem 1.6rem;
    font-size: 0.85rem;
    color: var(--text-secondary);
  }

  footer .footer-inner {
    background: var(--bg-panel);
    border-radius: 12px;
    padding: 1rem 1.2rem;
    box-shadow: 0 4px 18px rgba(30, 46, 90, 0.04);
  }

  .responsive-note {
    display: none;
    font-size: 0.85rem;
    color: var(--text-secondary);
  }

  @media (max-width: 1200px) {
    main {
      grid-template-columns: 280px minmax(0, 1fr);
      grid-template-rows: auto auto;
    }

    .right-panel {
      grid-column: 1 / -1;
    }
  }

  @media (max-width: 960px) {
    main {
      display: flex;
      flex-direction: column;
    }

    .responsive-note {
      display: block;
      margin-top: 0.6rem;
    }
  }
</style>
</head>
<body>
<div class="app-shell">
  <header>
    <h1>K-Means 互动实验室 · Interactive Lab</h1>
    <p class="intro-text">分配→更新→重复：调整质心、让簇内更紧密。Assign → Update → Repeat: move centroids to minimize within-cluster variance.</p>
    <div class="usage-banner" role="note">使用引导 / Quick Guide：先选择数据集与簇数，点击“运行”观察算法循环；需要学习内容请切换右侧标签页（概念 / 指标 / 小测 / 失效场景）。</div>
    <div class="responsive-note">📱 横屏体验更佳 · Landscape mode recommended for tablets.</div>
    <div class="top-controls" aria-label="top quick controls">
      <div class="control-block" aria-label="dataset selector">
        <label for="dataset-select">数据集 Dataset</label>
        <select id="dataset-select" aria-label="选择数据集 Select dataset">
          <option value="blobs">高斯团 Blobs</option>
          <option value="moons">双月牙 Moons</option>
          <option value="circles">同心环 Circles</option>
          <option value="grid">网格 Grid</option>
          <option value="custom">自定义 Custom</option>
        </select>
      </div>
      <div class="control-block" aria-label="cluster count">
        <label for="k-slider">簇数 k</label>
        <input id="k-slider" type="range" min="1" max="10" value="3" aria-label="簇数 K slider" />
        <input id="k-number" type="number" min="1" max="10" value="3" aria-label="簇数 K 数字" />
      </div>
      <div class="control-block" aria-label="initialization method">
        <label for="init-select">初始化 Initialization</label>
        <select id="init-select" aria-label="选择初始化方式">
          <option value="random">随机 Random</option>
          <option value="kpp">k-means++</option>
          <option value="manual">手动 Manual</option>
        </select>
      </div>
      <div class="control-block" aria-label="run controls">
        <label>运行控制 Run Controls</label>
        <div style="display:flex; gap:0.4rem; flex-wrap:wrap;">
          <button type="button" id="btn-run" class="icon-btn primary" aria-label="运行 Run">▶ Run</button>
          <button type="button" id="btn-pause" class="icon-btn" aria-label="暂停 Pause">⏸ Pause</button>
          <button type="button" id="btn-step" class="icon-btn" aria-label="单步 Step">⏭ Step</button>
          <button type="button" id="btn-reset" class="icon-btn" aria-label="重置 Reset">↺ Reset</button>
        </div>
      </div>
      <div class="control-block" aria-label="seed control">
        <label for="seed-input">随机种子 Seed</label>
        <div style="display:flex; gap:0.4rem;">
          <input id="seed-input" type="number" value="42" aria-label="随机种子输入 Seed input" />
          <button type="button" id="btn-random-seed" class="icon-btn" aria-label="随机骰子 Randomize">🎲</button>
        </div>
      </div>
      <div class="control-block" aria-label="speed control">
        <label for="speed-range">动画速度 Speed</label>
        <input id="speed-range" type="range" min="0" max="100" value="60" aria-label="动画速度 slider" />
      </div>
      <div class="control-block" aria-label="help buttons">
        <label>帮助 Help</label>
        <div style="display:flex; gap:0.4rem; flex-wrap:wrap;">
          <button type="button" class="icon-btn" aria-label="帮助说明 Help">❓ Help</button>
          <button type="button" class="icon-btn" aria-label="恢复默认 Reset defaults">🧹 Reset Defaults</button>
        </div>
      </div>
    </div>
  </header>
  <main>
    <aside class="panel controls-panel" aria-label="详细控制面板 Detailed controls">
      <section>
        <h2>参数调节 Parameters</h2>
        <div class="control-block">
          <label for="distance-select">距离 Distance</label>
          <select id="distance-select" aria-label="选择距离度量">
            <option value="euclidean">欧氏 Euclidean</option>
            <option value="manhattan">曼哈顿 Manhattan</option>
          </select>
        </div>
        <div class="control-block">
          <label for="max-iter">最大迭代 Max Iterations</label>
          <input id="max-iter" type="number" value="50" min="1" aria-label="最大迭代次数" />
        </div>
        <div class="control-block">
          <label for="point-count">点数量 Point Count</label>
          <input id="point-count" type="number" value="600" min="10" max="3000" aria-label="点数量" />
        </div>
        <div class="control-block">
          <label for="noise-slider">噪声 Noise Ratio</label>
          <input id="noise-slider" type="range" min="0" max="0.3" step="0.01" value="0.05" aria-label="噪声比例" />
        </div>
        <fieldset style="border:1px solid var(--border-color); border-radius:12px; padding:0.8rem;">
          <legend>可选视图 Options</legend>
          <label><input type="checkbox" id="show-voronoi" /> 显示 Voronoi / Show Voronoi</label><br />
          <label><input type="checkbox" id="show-trails" checked /> 质心轨迹 / Show Trails</label><br />
          <label><input type="checkbox" id="show-labels" /> 标签 / Labels</label><br />
          <label><input type="checkbox" id="show-heat" /> 热力背景 / Heatmap</label>
        </fieldset>
        <fieldset style="border:1px solid var(--border-color); border-radius:12px; padding:0.8rem;">
          <legend>数据处理 Data Prep</legend>
          <label><input type="checkbox" id="toggle-standardize" /> 标准化 / Standardize</label><br />
          <label><input type="checkbox" id="toggle-outliers" /> 加入离群点 / Add Outliers</label>
        </fieldset>
      </section>
      <section>
        <h2>导入导出 Import & Export</h2>
        <div class="control-block">
          <label for="csv-input">CSV 数据粘贴区 Paste CSV</label>
          <textarea id="csv-input" rows="6" aria-label="CSV 输入区域"></textarea>
        </div>
        <div style="display:flex; gap:0.6rem; flex-wrap:wrap;">
          <button type="button" class="icon-btn" aria-label="导入 CSV">⬆ Import</button>
          <button type="button" class="icon-btn" aria-label="导出 PNG">⬇ Export PNG</button>
          <button type="button" class="icon-btn" aria-label="导出参数 JSON">{} Export JSON</button>
        </div>
        <p class="hint-text" aria-live="polite">示例：x,y\n1,2\n3,4</p>
      </section>
      <section>
        <h2>AB 快照 AB Snapshots</h2>
        <div class="snapshot-grid" aria-label="快照列表">
          <div class="snapshot-placeholder" role="group" aria-label="快照槽位 snapshot slot">空 Empty</div>
          <div class="snapshot-placeholder" role="group" aria-label="快照槽位 snapshot slot">空 Empty</div>
          <div class="snapshot-placeholder" role="group" aria-label="快照槽位 snapshot slot">空 Empty</div>
        </div>
        <button type="button" class="icon-btn" aria-label="拍摄当前状态 Save snapshot">📸 Save Snapshot</button>
      </section>
    </aside>
    <section class="panel canvas-panel" aria-label="主可视化区域 Main visualization">
      <div class="canvas-header" style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <h2 style="margin:0; font-size:1.3rem;">聚类画布 Cluster Canvas</h2>
          <p style="margin:0; font-size:0.9rem; color:var(--text-secondary);">拖拽质心、观察分配；Drag centroids and inspect assignments.</p>
        </div>
        <div class="status-chips" style="display:flex; gap:0.4rem; flex-wrap:wrap;">
          <span class="chip" id="chip-status" aria-label="状态">状态：待初始化 · Ready</span>
          <span class="chip" id="chip-converged" aria-label="收敛状态">收敛 Convergence：--</span>
        </div>
      </div>
      <div class="canvas-wrapper" role="presentation">
        <canvas id="cluster-canvas" width="900" height="600" aria-label="k-means 可视化画布"></canvas>
        <div class="canvas-overlay" id="canvas-overlay" aria-live="polite">准备就绪：生成数据后点击运行观察聚类。Ready: generate data then press Run.</div>
      </div>
      <div class="metrics-bar" aria-label="实时指标">
        <div class="metric-card" role="status">
          <span>SSE 总和</span>
          <strong id="metric-sse">--</strong>
          <small>簇内平方和 Sum of Squared Errors</small>
        </div>
        <div class="metric-card" role="status">
          <span>轮廓系数 Silhouette</span>
          <strong id="metric-silhouette">--</strong>
          <small>抽样估计 Sampled estimation</small>
        </div>
        <div class="metric-card" role="status">
          <span>迭代 Iteration</span>
          <strong id="metric-iteration">0</strong>
          <small>最大迭代阈值 Max: 300</small>
        </div>
      </div>
      <div class="mini-charts" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px,1fr)); gap:0.8rem;">
        <div class="mini-chart" style="background:var(--tab-bg); border-radius:12px; padding:0.8rem;">
          <h3 style="margin:0 0 0.4rem; font-size:0.95rem;">损失曲线 Loss Curve</h3>
          <div class="chart-placeholder" style="height:120px; border:1px dashed var(--border-color); border-radius:10px; display:flex; align-items:center; justify-content:center; color:var(--text-secondary);">Mini Canvas</div>
        </div>
        <div class="mini-chart" style="background:var(--tab-bg); border-radius:12px; padding:0.8rem;">
          <h3 style="margin:0 0 0.4rem; font-size:0.95rem;">肘部法 Elbow</h3>
          <div class="chart-placeholder" style="height:120px; border:1px dashed var(--border-color); border-radius:10px; display:flex; align-items:center; justify-content:center; color:var(--text-secondary);">Mini Canvas</div>
        </div>
        <div class="mini-chart" style="background:var(--tab-bg); border-radius:12px; padding:0.8rem;">
          <h3 style="margin:0 0 0.4rem; font-size:0.95rem;">轮廓分布 Silhouette</h3>
          <div class="chart-placeholder" style="height:120px; border:1px dashed var(--border-color); border-radius:10px; display:flex; align-items:center; justify-content:center; color:var(--text-secondary);">Mini Canvas</div>
        </div>
      </div>
    </section>
    <aside class="panel right-panel" aria-label="学习与信息面板 Learning panel">
      <div class="tabs" role="tablist">
        <button class="active" role="tab" aria-selected="true" aria-controls="tab-concept" id="tab-btn-concept">概念 Concept</button>
        <button role="tab" aria-controls="tab-metrics" id="tab-btn-metrics">指标 Metrics</button>
        <button role="tab" aria-controls="tab-quiz" id="tab-btn-quiz">小测 Quiz</button>
        <button role="tab" aria-controls="tab-fail" id="tab-btn-fail">失效 Failure Cases</button>
      </div>
      <div class="tab-content">
        <div class="tab-pane active" id="tab-concept" role="tabpanel" aria-labelledby="tab-btn-concept">
          <section>
            <h3>算法流程 Algorithm Loop</h3>
            <p>1. 随机初始化质心。2. 将点分配到最近质心。3. 更新质心位置。4. 重复直至收敛。</p>
            <p>1. Initialize centroids. 2. Assign points to nearest centroid. 3. Update centroid mean. 4. Repeat until convergence.</p>
          </section>
          <section>
            <h3>适用场景 Use Cases</h3>
            <ul>
              <li>簇近似球形。Roughly spherical clusters.</li>
              <li>需要快速原型聚类。Rapid prototyping.</li>
            </ul>
          </section>
          <section>
            <h3>局限性 Limitations</h3>
            <ul>
              <li>对初始值敏感。Sensitive to initialization.</li>
              <li>不适合非凸簇。Not ideal for non-convex shapes.</li>
              <li>离群点影响显著。Outliers can skew centroids.</li>
            </ul>
          </section>
        </div>
        <div class="tab-pane" id="tab-metrics" role="tabpanel" aria-labelledby="tab-btn-metrics">
          <section>
            <h3>SSE 簇内平方和</h3>
            <p>度量每个簇内样本与质心的平方距离之和。值越小，聚类越紧凑。Measures total squared distance of points to centroid within each cluster.</p>
          </section>
          <section>
            <h3>Silhouette 轮廓系数</h3>
            <p>单点指标：(b - a) / max(a, b)。a 为簇内平均距离，b 为最近其他簇平均距离。Average silhouette 描述簇是否清晰。</p>
          </section>
          <section>
            <h3>肘部法 Elbow Method</h3>
            <p>绘制不同 k 的 SSE，寻找下降幅度转折点。Plot SSE vs k to find point of diminishing returns.</p>
          </section>
        </div>
        <div class="tab-pane" id="tab-quiz" role="tabpanel" aria-labelledby="tab-btn-quiz">
          <section>
            <h3>知识小测 Quiz</h3>
            <div class="quiz-question">
              <h4>Q1: 肘部法建议的 k 值通常对应哪里？Where is elbow located?</h4>
              <div class="quiz-options" role="group" aria-label="选项 Options">
                <label><input type="radio" name="quiz-q1" /> 在下降曲线的拐点 At the elbow point.</label>
                <label><input type="radio" name="quiz-q1" /> 最大的 k 值 Largest k.</label>
                <label><input type="radio" name="quiz-q1" /> 曲线起点 Curve start.</label>
              </div>
            </div>
            <div class="quiz-question">
              <h4>Q2: 标准化的作用是什么？Why standardize?</h4>
              <div class="quiz-options" role="group">
                <label><input type="radio" name="quiz-q2" /> 消除量纲影响 Remove scale bias.</label>
                <label><input type="radio" name="quiz-q2" /> 增加噪声 Increase noise.</label>
                <label><input type="radio" name="quiz-q2" /> 减少样本数量 Reduce samples.</label>
              </div>
            </div>
            <div class="quiz-question">
              <h4>Q3: 对“Moons”数据，k-means 表现如何？How does k-means perform on moons?</h4>
              <div class="quiz-options" role="group">
                <label><input type="radio" name="quiz-q3" /> 效果较差，簇非凸 Poor due to non-convex clusters.</label>
                <label><input type="radio" name="quiz-q3" /> 非常好 Very good.</label>
                <label><input type="radio" name="quiz-q3" /> 无法运行 Cannot run.</label>
              </div>
            </div>
            <div class="quiz-question">
              <h4>Q4: 轮廓系数接近 -1 表示什么？What does silhouette near -1 mean?</h4>
              <div class="quiz-options" role="group">
                <label><input type="radio" name="quiz-q4" /> 样本更接近其他簇 Point closer to other cluster.</label>
                <label><input type="radio" name="quiz-q4" /> 聚类完美 Perfect clustering.</label>
                <label><input type="radio" name="quiz-q4" /> 样本孤立 Isolated point.</label>
              </div>
            </div>
            <button type="button" class="primary" aria-label="提交测验 Submit quiz">提交 Submit</button>
            <button type="button" aria-label="重新作答 Retake">重新作答 Retake</button>
          </section>
        </div>
        <div class="tab-pane" id="tab-fail" role="tabpanel" aria-labelledby="tab-btn-fail">
          <section>
            <h3>何时失效 When It Fails</h3>
            <ul>
              <li>非凸数据（如 Moons）。Non-convex data (Moons).</li>
              <li>簇密度差异大。Different densities.</li>
              <li>离群点过多。Too many outliers.</li>
            </ul>
          </section>
          <section>
            <h3>实践建议 Practical Tips</h3>
            <ul>
              <li>尝试多个随机种子。Try multiple seeds.</li>
              <li>结合领域知识。Align with domain knowledge.</li>
            </ul>
          </section>
        </div>
      </div>
    </aside>
  </main>
  <section class="panel" style="margin:0 1.5rem 1.5rem;" aria-label="学习总结区域 Summary">
    <h2>学习总结 Summary</h2>
    <p>一键生成学习总结（后续阶段实现）。Generate learning summary (to be implemented in later phase).</p>
    <div style="display:flex; gap:0.6rem; flex-wrap:wrap;">
      <button type="button" class="icon-btn" aria-label="生成总结 Generate summary">📝 Generate Summary</button>
      <button type="button" class="icon-btn" aria-label="复制总结 Copy summary">📋 Copy</button>
      <button type="button" class="icon-btn" aria-label="下载总结 Download summary">💾 Download</button>
    </div>
    <textarea id="summary-output" rows="4" aria-label="总结输出区域" placeholder="总结文本将在后续阶段生成..."></textarea>
  </section>
  <footer>
    <div class="footer-inner">
      <p>© 2025 K-Means Interactive Lesson · 作者 Author: OpenAI 助手 · 更新日期 Updated: Phase 2</p>
      <p>键盘快捷键：Space 运行/暂停 · S 单步 · R 重置 · K 聚焦 k 滑块 · H 帮助（即将到来）。Keyboard shortcuts coming soon.</p>
    </div>
  </footer>
</div>
<!-- ===== HTML Markup ===== -->
<!-- ===== App State & Utils ===== -->
<script>
  const KMeansApp = (() => {
    const state = {
      points: [],
      centroids: [],
      assignments: [],
      running: false,
      iteration: 0,
      converged: false,
      delay: 480,
      trails: [],
      manualAwait: 0,
      maxIterations: 300,
      dpr: window.devicePixelRatio || 1,
      rngSeed: 42,
      requestId: null,
      overlayTimeout: null,
    };

    const palette = [
      "#f94144",
      "#f3722c",
      "#f8961e",
      "#f9c74f",
      "#90be6d",
      "#43aa8b",
      "#577590",
      "#4d908e",
      "#277da1",
      "#9c89b8",
    ];

    const elements = {};

    function createMulberry32(seed) {
      let t = seed >>> 0;
      return () => {
        t += 0x6d2b79f5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    function cacheDom() {
      elements.canvas = document.getElementById("cluster-canvas");
      elements.overlay = document.getElementById("canvas-overlay");
      elements.ctx = elements.canvas.getContext("2d");
      elements.datasetSelect = document.getElementById("dataset-select");
      elements.kSlider = document.getElementById("k-slider");
      elements.kNumber = document.getElementById("k-number");
      elements.initSelect = document.getElementById("init-select");
      elements.distanceSelect = document.getElementById("distance-select");
      elements.maxIterInput = document.getElementById("max-iter");
      elements.pointCountInput = document.getElementById("point-count");
      elements.noiseSlider = document.getElementById("noise-slider");
      elements.seedInput = document.getElementById("seed-input");
      elements.speedRange = document.getElementById("speed-range");
      elements.showVoronoi = document.getElementById("show-voronoi");
      elements.showTrails = document.getElementById("show-trails");
      elements.showLabels = document.getElementById("show-labels");
      elements.showHeat = document.getElementById("show-heat");
      elements.toggleStandardize = document.getElementById("toggle-standardize");
      elements.toggleOutliers = document.getElementById("toggle-outliers");
      elements.metricSSE = document.getElementById("metric-sse");
      elements.metricSilhouette = document.getElementById("metric-silhouette");
      elements.metricIteration = document.getElementById("metric-iteration");
      elements.btnRun = document.getElementById("btn-run");
      elements.btnPause = document.getElementById("btn-pause");
      elements.btnStep = document.getElementById("btn-step");
      elements.btnReset = document.getElementById("btn-reset");
      elements.btnRandomSeed = document.getElementById("btn-random-seed");
      elements.chipStatus = document.getElementById("chip-status");
      elements.chipConverged = document.getElementById("chip-converged");
    }

    function linkRangeAndNumber(rangeEl, numberEl, onChange) {
      const sync = (value, source) => {
        const v = Math.min(parseInt(rangeEl.max, 10), Math.max(parseInt(rangeEl.min, 10), parseInt(value, 10)));
        if (source !== rangeEl) rangeEl.value = v;
        if (source !== numberEl) numberEl.value = v;
        if (typeof onChange === "function") onChange(v);
      };
      rangeEl.addEventListener("input", (e) => sync(e.target.value, rangeEl));
      numberEl.addEventListener("change", (e) => sync(e.target.value, numberEl));
    }

    function resizeCanvas() {
      const rect = elements.canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      if (!rect.width || !rect.height) return;
      elements.canvas.width = rect.width * dpr;
      elements.canvas.height = rect.height * dpr;
      state.canvasWidth = rect.width;
      state.canvasHeight = rect.height;
      state.dpr = dpr;
      elements.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      render();
    }

    function attachEvents() {
      window.addEventListener("resize", () => {
        clearTimeout(state.overlayTimeout);
        state.overlayTimeout = setTimeout(resizeCanvas, 200);
      });

      linkRangeAndNumber(elements.kSlider, elements.kNumber, () => {
        if (elements.initSelect.value !== "manual") {
          initializeCentroids();
          render();
        } else {
          prepareManualPlacement();
        }
        updateStatusChip();
      });

      elements.datasetSelect.addEventListener("change", () => {
        regenerateDataset();
      });

      elements.initSelect.addEventListener("change", () => {
        if (elements.initSelect.value === "manual") {
          prepareManualPlacement();
        } else {
          initializeCentroids();
          render();
        }
      });

      elements.distanceSelect.addEventListener("change", () => {
        render();
      });

      elements.maxIterInput.addEventListener("change", () => {
        state.maxIterations = Math.max(1, parseInt(elements.maxIterInput.value, 10) || 1);
      });

      elements.pointCountInput.addEventListener("change", () => regenerateDataset());
      elements.noiseSlider.addEventListener("input", () => regenerateDataset());
      elements.toggleStandardize.addEventListener("change", () => regenerateDataset());
      elements.toggleOutliers.addEventListener("change", () => regenerateDataset());

      elements.btnRun.addEventListener("click", () => setRunning(true));
      elements.btnPause.addEventListener("click", () => setRunning(false));
      elements.btnStep.addEventListener("click", () => {
        if (!ensureCentroidsReady()) return;
        performIteration();
        render();
      });
      elements.btnReset.addEventListener("click", () => regenerateDataset());
      elements.btnRandomSeed.addEventListener("click", () => {
        const newSeed = Math.floor(Math.random() * 100000);
        elements.seedInput.value = newSeed;
        state.rngSeed = newSeed;
        regenerateDataset();
      });

      elements.seedInput.addEventListener("change", () => {
        const seedValue = parseInt(elements.seedInput.value, 10);
        if (!Number.isFinite(seedValue)) {
          elements.seedInput.value = state.rngSeed;
          return;
        }
        state.rngSeed = seedValue;
        regenerateDataset();
      });

      elements.speedRange.addEventListener("input", () => {
        const value = parseInt(elements.speedRange.value, 10);
        state.delay = 700 - Math.min(650, value * 6.2);
      });

      elements.showVoronoi.addEventListener("change", () => render());
      elements.showTrails.addEventListener("change", () => render());
      elements.showLabels.addEventListener("change", () => render());
      elements.showHeat.addEventListener("change", () => render());

      elements.canvas.addEventListener("click", (event) => {
        if (elements.initSelect.value !== "manual") return;
        if (!state.points.length) return;
        const rect = elements.canvas.getBoundingClientRect();
        const nx = (event.clientX - rect.left) / rect.width;
        const ny = (event.clientY - rect.top) / rect.height;
        if (state.centroids.length < getK()) {
          state.centroids.push({ x: nx, y: ny, trail: [] });
          state.trails.push([{ x: nx, y: ny }]);
          state.manualAwait = getK() - state.centroids.length;
          updateOverlay();
          render();
        }
        if (state.centroids.length === getK()) {
          elements.overlay.dataset.manual = "done";
          setOverlayText("质心已放置，可运行算法。Centroids placed, press Run.");
        }
      });

      document.addEventListener("keydown", (event) => {
        if (event.target && ["INPUT", "TEXTAREA"].includes(event.target.tagName)) return;
        switch (event.key.toLowerCase()) {
          case " ":
            event.preventDefault();
            setRunning(!state.running);
            break;
          case "s":
            event.preventDefault();
            setRunning(false);
            performIteration();
            render();
            break;
          case "r":
            event.preventDefault();
            regenerateDataset();
            break;
          case "k":
            event.preventDefault();
            elements.kSlider.focus();
            break;
          default:
            break;
        }
      });
    }

    function getK() {
      return Math.max(1, parseInt(elements.kSlider.value, 10) || 1);
    }

    function regenerateDataset() {
      setRunning(false);
      const datasetType = elements.datasetSelect.value;
      const count = Math.max(10, parseInt(elements.pointCountInput.value, 10) || 300);
      const noise = parseFloat(elements.noiseSlider.value) || 0;
      const rng = createMulberry32(state.rngSeed);
      let points = [];
      if (datasetType === "blobs") points = generateBlobs(count, noise, rng);
      else if (datasetType === "circles") points = generateCircles(count, noise, rng);
      else if (datasetType === "moons") points = generateMoons(count, noise, rng);
      else if (datasetType === "grid") points = generateGrid(count, noise, rng);
      else points = generateCustom(count, noise, rng);

      if (elements.toggleStandardize.checked) {
        points = standardizePoints(points);
      } else {
        points = normalizePoints(points);
      }

      if (elements.toggleOutliers.checked) {
        const outliers = Math.max(1, Math.floor(points.length * 0.05));
        for (let i = 0; i < outliers; i += 1) {
          points.push({
            x: rng() * 1.4 - 0.2,
            y: rng() * 1.4 - 0.2,
          });
        }
      }

      state.points = points.map((p) => ({ x: p.x, y: p.y }));
      state.assignments = new Array(state.points.length).fill(-1);
      state.iteration = 0;
      state.converged = false;
      state.trails = [];
      elements.metricIteration.textContent = "0";
      elements.metricSSE.textContent = "--";
      elements.metricSilhouette.textContent = "--";
      elements.chipConverged.textContent = "收敛 Convergence：--";
      updateStatusChip();
      updateOverlay();
      initializeCentroids();
      render();
    }

    function standardizePoints(points) {
      if (!points.length) return points;
      const mean = points.reduce(
        (acc, p) => {
          acc.x += p.x;
          acc.y += p.y;
          return acc;
        },
        { x: 0, y: 0 }
      );
      mean.x /= points.length;
      mean.y /= points.length;
      let sumSqX = 0;
      let sumSqY = 0;
      points.forEach((p) => {
        sumSqX += (p.x - mean.x) ** 2;
        sumSqY += (p.y - mean.y) ** 2;
      });
      const stdX = Math.sqrt(sumSqX / points.length) || 1;
      const stdY = Math.sqrt(sumSqY / points.length) || 1;
      const standardized = points.map((p) => ({
        x: (p.x - mean.x) / stdX,
        y: (p.y - mean.y) / stdY,
      }));
      return normalizePoints(standardized);
    }

    function normalizePoints(points) {
      if (!points.length) return points;
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      points.forEach((p) => {
        if (p.x < minX) minX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.x > maxX) maxX = p.x;
        if (p.y > maxY) maxY = p.y;
      });
      const spanX = maxX - minX || 1;
      const spanY = maxY - minY || 1;
      return points.map((p) => ({
        x: (p.x - minX) / spanX,
        y: (p.y - minY) / spanY,
      }));
    }

    function initializeCentroids() {
      state.centroids = [];
      state.trails = [];
      state.manualAwait = 0;
      const k = getK();
      if (!state.points.length) return;
      if (elements.initSelect.value === "manual") {
        prepareManualPlacement();
        render();
        return;
      }
      const rng = createMulberry32(state.rngSeed + 99);
      if (elements.initSelect.value === "kpp" && state.points.length) {
        const chosen = [];
        const distances = new Array(state.points.length).fill(Infinity);
        chosen.push(randomPoint(rng));
        for (let c = 1; c < k; c += 1) {
          for (let i = 0; i < state.points.length; i += 1) {
            const d = euclideanDistance(state.points[i], chosen[c - 1]);
            if (d < distances[i]) distances[i] = d;
          }
          const sum = distances.reduce((acc, val) => acc + val, 0);
          let threshold = rng() * sum;
          let nextIndex = 0;
          for (let i = 0; i < distances.length; i += 1) {
            threshold -= distances[i];
            if (threshold <= 0) {
              nextIndex = i;
              break;
            }
          }
          chosen.push({ ...state.points[nextIndex] });
        }
        state.centroids = chosen.map((p) => ({ x: p.x, y: p.y, trail: [] }));
      } else {
        const used = new Set();
        while (state.centroids.length < k) {
          const idx = Math.floor(rng() * state.points.length);
          if (used.has(idx)) continue;
          used.add(idx);
          const point = state.points[idx];
          state.centroids.push({ x: point.x, y: point.y, trail: [] });
        }
      }
      state.trails = state.centroids.map((c) => [{ x: c.x, y: c.y }]);
      updateOverlay();
    }

    function randomPoint(rng) {
      const idx = Math.floor(rng() * state.points.length);
      return { ...state.points[idx] };
    }

    function prepareManualPlacement() {
      state.centroids = [];
      state.trails = [];
      state.manualAwait = getK();
      setRunning(false);
      setOverlayText(`手动放置质心：需选择 ${state.manualAwait} 个点位。Click ${state.manualAwait} times to place centroids.`);
    }

    function ensureCentroidsReady() {
      if (!state.points.length) return false;
      if (state.centroids.length === getK()) return true;
      if (elements.initSelect.value === "manual") {
        setOverlayText("请先在画布上放置全部质心。Place all centroids before running.");
        return false;
      }
      initializeCentroids();
      return state.centroids.length === getK();
    }

    function setRunning(running) {
      if (running && !ensureCentroidsReady()) return;
      state.running = running;
      if (running) {
        state.lastTimestamp = 0;
        loop(performance.now());
        setOverlayText("运行中…点击暂停可停止。Running… press Pause to stop.", 2000);
      } else if (state.requestId) {
        cancelAnimationFrame(state.requestId);
        state.requestId = null;
      }
      updateStatusChip();
      updateOverlay();
      render();
    }

    function loop(timestamp) {
      if (!state.running) return;
      if (!state.lastTimestamp) state.lastTimestamp = timestamp;
      const elapsed = timestamp - state.lastTimestamp;
      if (elapsed >= state.delay) {
        state.lastTimestamp = timestamp;
        performIteration();
      }
      render();
      state.requestId = requestAnimationFrame(loop);
    }

    function performIteration() {
      if (!state.points.length || !state.centroids.length) return;
      state.iteration += 1;
      const assignments = [];
      const counts = Array(state.centroids.length).fill(0);
      const sums = Array(state.centroids.length)
        .fill(0)
        .map(() => ({ x: 0, y: 0 }));
      for (let i = 0; i < state.points.length; i += 1) {
        const point = state.points[i];
        let bestDist = Infinity;
        let bestIdx = 0;
        for (let c = 0; c < state.centroids.length; c += 1) {
          const dist = distance(point, state.centroids[c]);
          if (dist < bestDist) {
            bestDist = dist;
            bestIdx = c;
          }
        }
        assignments[i] = bestIdx;
        counts[bestIdx] += 1;
        sums[bestIdx].x += point.x;
        sums[bestIdx].y += point.y;
      }

      handleEmptyClusters(counts, assignments, sums);

      const epsilon = 1e-4;
      let maxShift = 0;
      for (let c = 0; c < state.centroids.length; c += 1) {
        const centroid = state.centroids[c];
        const count = counts[c];
        if (count === 0) continue;
        const newX = sums[c].x / count;
        const newY = sums[c].y / count;
        const shift = Math.sqrt((centroid.x - newX) ** 2 + (centroid.y - newY) ** 2);
        if (elements.showTrails.checked) {
          const trail = state.trails[c];
          trail.push({ x: newX, y: newY });
          if (trail.length > 50) trail.shift();
        }
        centroid.x = newX;
        centroid.y = newY;
        if (shift > maxShift) maxShift = shift;
      }

      state.assignments = assignments;
      const sse = computeSSE(assignments);
      const silhouette = computeSilhouette(assignments);
      state.converged = maxShift < epsilon || state.iteration >= state.maxIterations;
      if (state.converged) {
        setRunning(false);
        elements.chipConverged.textContent = `收敛 Convergence：${maxShift < epsilon ? "是 Yes" : "达到阈值 Max"}`;
      }
      elements.metricIteration.textContent = state.iteration.toString();
      elements.metricSSE.textContent = sse.toFixed(2);
      elements.metricSilhouette.textContent = Number.isFinite(silhouette)
        ? silhouette.toFixed(3)
        : "--";
      updateStatusChip();
    }

    function handleEmptyClusters(counts, assignments, sums) {
      const epsilon = 1e-6;
      for (let c = 0; c < counts.length; c += 1) {
        if (counts[c] > 0) continue;
        let farthestIdx = -1;
        let farthestDist = -Infinity;
        for (let i = 0; i < state.points.length; i += 1) {
          const minDist = state.centroids.reduce((min, centroid, idx) => {
            if (idx === c) return min;
            const d = distance(state.points[i], centroid);
            return d < min ? d : min;
          }, Infinity);
          if (minDist > farthestDist + epsilon) {
            farthestDist = minDist;
            farthestIdx = i;
          }
        }
        if (farthestIdx === -1) continue;
        const point = state.points[farthestIdx];
        const prev = assignments[farthestIdx];
        if (prev >= 0 && prev !== c) {
          counts[prev] = Math.max(0, counts[prev] - 1);
          sums[prev].x -= point.x;
          sums[prev].y -= point.y;
        }
        state.centroids[c].x = point.x;
        state.centroids[c].y = point.y;
        state.trails[c] = [{ x: point.x, y: point.y }];
        assignments[farthestIdx] = c;
        counts[c] = 1;
        sums[c].x = point.x;
        sums[c].y = point.y;
        c = -1; // restart to ensure cascading empties handled
      }
    }

    function computeSSE(assignments) {
      let total = 0;
      for (let i = 0; i < state.points.length; i += 1) {
        const clusterIdx = assignments[i];
        if (clusterIdx < 0) continue;
        const centroid = state.centroids[clusterIdx];
        total += euclideanDistance(state.points[i], centroid) ** 2;
      }
      return total;
    }

    function computeSilhouette(assignments) {
      const n = state.points.length;
      if (!n || state.centroids.length < 2) return NaN;
      const clusters = Array.from({ length: state.centroids.length }, () => []);
      for (let i = 0; i < n; i += 1) {
        const clusterIdx = assignments[i];
        if (clusterIdx >= 0) clusters[clusterIdx].push(i);
      }
      const sampleSize = Math.min(300, n);
      const rng = createMulberry32(state.rngSeed + state.iteration + 7);
      let sumSilhouette = 0;
      for (let s = 0; s < sampleSize; s += 1) {
        const idx = Math.floor(rng() * n);
        const clusterIdx = assignments[idx];
        if (clusterIdx < 0) continue;
        const ownCluster = clusters[clusterIdx];
        const point = state.points[idx];
        let a = 0;
        if (ownCluster.length > 1) {
          let total = 0;
          for (let j = 0; j < ownCluster.length; j += 1) {
            const otherIdx = ownCluster[j];
            if (otherIdx === idx) continue;
            total += euclideanDistance(point, state.points[otherIdx]);
          }
          a = total / Math.max(1, ownCluster.length - 1);
        }
        let b = Infinity;
        for (let c = 0; c < clusters.length; c += 1) {
          if (c === clusterIdx || clusters[c].length === 0) continue;
          let total = 0;
          for (let j = 0; j < clusters[c].length; j += 1) {
            total += euclideanDistance(point, state.points[clusters[c][j]]);
          }
          const avg = total / clusters[c].length;
          if (avg < b) b = avg;
        }
        if (!Number.isFinite(b)) continue;
        const denom = Math.max(a, b);
        const sVal = denom === 0 ? 0 : (b - a) / denom;
        sumSilhouette += sVal;
      }
      return sumSilhouette / sampleSize;
    }

    function distance(a, b) {
      return elements.distanceSelect.value === "manhattan"
        ? Math.abs(a.x - b.x) + Math.abs(a.y - b.y)
        : Math.hypot(a.x - b.x, a.y - b.y);
    }

    function euclideanDistance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function updateStatusChip() {
      elements.chipStatus.textContent = `状态 Status：${state.running ? "运行中 Running" : "已就绪 Ready"}`;
    }

    function setOverlayText(text, timeout = 0) {
      if (!elements.overlay) return;
      elements.overlay.textContent = text;
      elements.overlay.style.opacity = 1;
      if (timeout > 0) {
        clearTimeout(state.overlayTimeout);
        state.overlayTimeout = setTimeout(() => {
          elements.overlay.style.opacity = 0;
        }, timeout);
      }
    }

    function updateOverlay() {
      if (!elements.overlay) return;
      if (!state.points.length) {
        setOverlayText("未生成数据。检查设置后重试。No dataset yet, adjust parameters.");
        return;
      }
      if (elements.initSelect.value === "manual") {
        if (state.centroids.length < getK()) {
          setOverlayText(`手动放置质心：剩余 ${getK() - state.centroids.length} 个。Place ${
            getK() - state.centroids.length
          } centroids.`);
        } else {
          setOverlayText("质心已放置，可运行算法。Centroids ready.", 2000);
        }
      } else if (state.running) {
        setOverlayText("运行中… Running…", 0);
      } else {
        setOverlayText("点击运行或单步查看聚类过程。Press Run or Step to iterate.", 2200);
      }
    }

    function render() {
      if (!elements.ctx || !state.canvasWidth || !state.canvasHeight) return;
      const ctx = elements.ctx;
      ctx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
      if (elements.showHeat.checked && state.centroids.length) drawHeatmap(ctx);
      if (elements.showVoronoi.checked && state.centroids.length) drawVoronoi(ctx);
      drawPoints(ctx);
      if (elements.showTrails.checked) drawTrails(ctx);
      drawCentroids(ctx);
    }

    function drawPoints(ctx) {
      const radius = Math.max(2, Math.min(state.canvasWidth, state.canvasHeight) * 0.007);
      ctx.save();
      ctx.lineWidth = 0;
      for (let i = 0; i < state.points.length; i += 1) {
        const p = state.points[i];
        const assignment = state.assignments[i];
        const color = assignment >= 0 ? palette[assignment % palette.length] : "#666";
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p.x * state.canvasWidth, p.y * state.canvasHeight, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawCentroids(ctx) {
      const size = Math.max(8, Math.min(state.canvasWidth, state.canvasHeight) * 0.02);
      ctx.save();
      ctx.lineWidth = 2;
      for (let i = 0; i < state.centroids.length; i += 1) {
        const centroid = state.centroids[i];
        const color = palette[i % palette.length];
        const x = centroid.x * state.canvasWidth;
        const y = centroid.y * state.canvasHeight;
        ctx.fillStyle = color;
        ctx.strokeStyle = "#1f2933";
        ctx.beginPath();
        ctx.moveTo(x, y - size);
        ctx.lineTo(x + size * 0.7, y + size * 0.7);
        ctx.lineTo(x - size * 0.7, y + size * 0.7);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        if (elements.showLabels.checked) {
          ctx.font = "14px/1.2 \"Segoe UI\", sans-serif";
          ctx.fillStyle = "#1e1e2f";
          ctx.fillText(`C${i + 1}`, x + size * 0.8, y - size * 0.6);
        }
      }
      ctx.restore();
    }

    function drawTrails(ctx) {
      ctx.save();
      ctx.lineWidth = 1.6;
      ctx.setLineDash([4, 4]);
      for (let i = 0; i < state.trails.length; i += 1) {
        const trail = state.trails[i];
        if (!trail || trail.length < 2) continue;
        const color = palette[i % palette.length];
        ctx.strokeStyle = color;
        ctx.beginPath();
        for (let t = 0; t < trail.length; t += 1) {
          const pos = trail[t];
          const px = pos.x * state.canvasWidth;
          const py = pos.y * state.canvasHeight;
          if (t === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      ctx.restore();
      ctx.setLineDash([]);
    }

    function drawVoronoi(ctx) {
      const step = 24;
      const width = state.canvasWidth;
      const height = state.canvasHeight;
      for (let y = 0; y <= height; y += step) {
        for (let x = 0; x <= width; x += step) {
          let bestIdx = 0;
          let bestDist = Infinity;
          const point = { x: x / width, y: y / height };
          for (let c = 0; c < state.centroids.length; c += 1) {
            const dist = distance(point, state.centroids[c]);
            if (dist < bestDist) {
              bestDist = dist;
              bestIdx = c;
            }
          }
          ctx.fillStyle = `${palette[bestIdx % palette.length]}20`;
          ctx.fillRect(x - step / 2, y - step / 2, step, step);
        }
      }
    }

    function drawHeatmap(ctx) {
      const step = 18;
      const width = state.canvasWidth;
      const height = state.canvasHeight;
      for (let y = 0; y <= height; y += step) {
        for (let x = 0; x <= width; x += step) {
          const point = { x: x / width, y: y / height };
          let minDist = Infinity;
          for (let c = 0; c < state.centroids.length; c += 1) {
            const dist = distance(point, state.centroids[c]);
            if (dist < minDist) minDist = dist;
          }
          const alpha = Math.max(0, 1 - minDist * 1.5);
          ctx.fillStyle = `rgba(76, 110, 245, ${alpha * 0.25})`;
          ctx.fillRect(x - step / 2, y - step / 2, step, step);
        }
      }
    }

    function generateBlobs(count, noise, rng) {
      const centers = [
        { x: 0.3, y: 0.3 },
        { x: 0.7, y: 0.35 },
        { x: 0.45, y: 0.75 },
        { x: 0.75, y: 0.7 },
      ];
      const points = [];
      for (let i = 0; i < count; i += 1) {
        const c = centers[Math.floor(rng() * centers.length)];
        const spread = 0.12 + noise * 0.4;
        points.push({
          x: c.x + (rng() - 0.5) * spread,
          y: c.y + (rng() - 0.5) * spread,
        });
      }
      return points;
    }

    function generateCircles(count, noise, rng) {
      const points = [];
      for (let i = 0; i < count; i += 1) {
        const outer = i % 2 === 0;
        const radius = outer ? 0.38 : 0.2;
        const angle = rng() * Math.PI * 2;
        const jitter = noise * 0.3;
        const r = radius + (rng() - 0.5) * jitter;
        points.push({
          x: 0.5 + Math.cos(angle) * r,
          y: 0.5 + Math.sin(angle) * r,
        });
      }
      return points;
    }

    function generateMoons(count, noise, rng) {
      const points = [];
      const half = Math.floor(count / 2);
      for (let i = 0; i < half; i += 1) {
        const angle = Math.PI * (i / half) + rng() * noise * 1.2;
        points.push({
          x: 0.25 + Math.cos(angle) * 0.3 + rng() * noise * 0.3,
          y: 0.45 + Math.sin(angle) * 0.2 + rng() * noise * 0.3,
        });
      }
      for (let i = 0; i < count - half; i += 1) {
        const angle = Math.PI * (i / half) + rng() * noise * 1.2;
        points.push({
          x: 0.55 + Math.cos(Math.PI - angle) * 0.3 + rng() * noise * 0.3,
          y: 0.55 - Math.sin(Math.PI - angle) * 0.2 + rng() * noise * 0.3,
        });
      }
      return points;
    }

    function generateGrid(count, noise, rng) {
      const size = Math.max(2, Math.floor(Math.sqrt(count)));
      const points = [];
      for (let i = 0; i < size; i += 1) {
        for (let j = 0; j < size; j += 1) {
          points.push({
            x: (i + 0.5 + (rng() - 0.5) * noise) / size,
            y: (j + 0.5 + (rng() - 0.5) * noise) / size,
          });
        }
      }
      while (points.length > count) points.pop();
      return points;
    }

    function generateCustom(count, noise, rng) {
      const points = [];
      for (let i = 0; i < count; i += 1) {
        points.push({ x: rng(), y: rng() });
      }
      if (noise > 0.01) {
        const extra = Math.floor(count * noise * 0.5);
        for (let i = 0; i < extra; i += 1) {
          points.push({ x: rng(), y: rng() });
        }
      }
      return points;
    }

    function init() {
      cacheDom();
      attachEvents();
      state.maxIterations = parseInt(elements.maxIterInput.value, 10) || 300;
      state.delay = 700 - Math.min(650, parseInt(elements.speedRange.value, 10) * 6.2 || 0);
      state.rngSeed = parseInt(elements.seedInput.value, 10) || 42;
      resizeCanvas();
      regenerateDataset();
      console.info("K-Means Lab Phase 2 ready.");
    }

    return { init };
  })();

  document.addEventListener("DOMContentLoaded", () => {
    KMeansApp.init();
  });
</script>
</body>
</html>
