<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>K-Means äº’åŠ¨è¯¾ä»¶ | Phase 2 Logic</title>
<!-- ===== Styles ===== -->
<style>
  :root {
    color-scheme: light dark;
    --bg-main: #f5f6fa;
    --bg-panel: #ffffff;
    --bg-accent: #eef2ff;
    --text-primary: #1e1e2f;
    --text-secondary: #3d3d52;
    --border-color: #d0d4e4;
    --accent: #4c6ef5;
    --focus-outline: #ff922b;
    --tab-bg: #f0f3ff;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Microsoft YaHei", sans-serif;
    background: var(--bg-main);
    color: var(--text-primary);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  body:focus-visible {
    outline: none;
  }

  a {
    color: inherit;
  }

  .app-shell {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }

  header {
    background: var(--bg-panel);
    box-shadow: 0 2px 8px rgba(30, 46, 90, 0.08);
    padding: 1.2rem 1.6rem;
    position: sticky;
    top: 0;
    z-index: 10;
  }

  header h1 {
    margin: 0 0 0.4rem;
    font-size: 1.8rem;
    font-weight: 700;
  }

  .intro-text {
    margin: 0;
    font-size: 0.95rem;
    color: var(--text-secondary);
    line-height: 1.6;
  }

  .usage-banner {
    margin-top: 0.8rem;
    padding: 0.8rem 1rem;
    background: var(--bg-accent);
    border-radius: 12px;
    font-size: 0.9rem;
  }

  .top-controls {
    margin-top: 1.4rem;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 0.8rem;
  }

  .control-block {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }

  .control-block label {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-secondary);
  }

  .control-block select,
  .control-block input,
  .control-block button {
    padding: 0.45rem 0.6rem;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    background: #fff;
    font-size: 0.95rem;
    transition: border 0.2s ease, box-shadow 0.2s ease;
  }

  button.primary {
    background: var(--accent);
    color: #fff;
    border: none;
  }

  button.icon-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.4rem;
    font-weight: 600;
  }

  button:focus-visible,
  input:focus-visible,
  select:focus-visible,
  textarea:focus-visible {
    outline: 2px solid var(--focus-outline);
    outline-offset: 2px;
  }

  main {
    flex: 1;
    display: grid;
    grid-template-columns: 320px minmax(0, 1fr) 340px;
    gap: 1rem;
    padding: 1rem 1.5rem 1.5rem;
  }

  .panel {
    background: var(--bg-panel);
    border-radius: 16px;
    padding: 1rem;
    box-shadow: 0 4px 18px rgba(30, 46, 90, 0.06);
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .controls-panel {
    overflow-y: auto;
  }

  .canvas-panel {
    display: flex;
    flex-direction: column;
  }

  .canvas-wrapper {
    flex: 1;
    background: linear-gradient(135deg, rgba(76, 110, 245, 0.08), rgba(135, 206, 250, 0.12));
    border-radius: 18px;
    position: relative;
    border: 1px dashed rgba(76, 110, 245, 0.3);
  }

  canvas#cluster-canvas {
    width: 100%;
    height: 100%;
    display: block;
    border-radius: 18px;
  }

  .canvas-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    color: var(--text-secondary);
    font-size: 1rem;
    text-align: center;
    padding: 1rem;
  }

  .metrics-bar {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 0.8rem;
    margin-top: 1rem;
  }

  .metric-card {
    background: var(--tab-bg);
    padding: 0.8rem;
    border-radius: 12px;
    font-size: 0.85rem;
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }

  .metric-card strong {
    font-size: 1rem;
  }

  .tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
  }

  .tabs button {
    flex: 1;
    background: transparent;
    border: none;
    padding: 0.8rem 0.6rem;
    font-weight: 600;
    cursor: pointer;
    border-bottom: 3px solid transparent;
  }

  .tabs button.active {
    border-bottom-color: var(--accent);
    color: var(--accent);
  }

  .tab-content {
    flex: 1;
  }

  .tab-pane {
    display: none;
  }

  .tab-pane.active {
    display: block;
  }

  .tab-pane section {
    margin-bottom: 1rem;
  }

  .tab-pane h3 {
    margin: 0 0 0.6rem;
    font-size: 1.05rem;
  }

  .tab-pane p,
  .tab-pane ul,
  .tab-pane li {
    font-size: 0.92rem;
    line-height: 1.6;
  }

  .quiz-question {
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 0.9rem;
    margin-bottom: 0.8rem;
  }

  .quiz-question h4 {
    margin: 0 0 0.6rem;
    font-size: 0.98rem;
  }

  .quiz-options {
    display: grid;
    gap: 0.6rem;
  }

  footer {
    margin-top: auto;
    padding: 1rem 1.6rem 1.6rem;
    font-size: 0.85rem;
    color: var(--text-secondary);
  }

  footer .footer-inner {
    background: var(--bg-panel);
    border-radius: 12px;
    padding: 1rem 1.2rem;
    box-shadow: 0 4px 18px rgba(30, 46, 90, 0.04);
  }

  .responsive-note {
    display: none;
    font-size: 0.85rem;
    color: var(--text-secondary);
  }

  @media (max-width: 1200px) {
    main {
      grid-template-columns: 280px minmax(0, 1fr);
      grid-template-rows: auto auto;
    }

    .right-panel {
      grid-column: 1 / -1;
    }
  }

  @media (max-width: 960px) {
    main {
      display: flex;
      flex-direction: column;
    }

    .responsive-note {
      display: block;
      margin-top: 0.6rem;
    }
  }
</style>
</head>
<body>
<div class="app-shell">
  <header>
    <h1>K-Means äº’åŠ¨å®éªŒå®¤ Â· Interactive Lab</h1>
    <p class="intro-text">åˆ†é…â†’æ›´æ–°â†’é‡å¤ï¼šè°ƒæ•´è´¨å¿ƒã€è®©ç°‡å†…æ›´ç´§å¯†ã€‚Assign â†’ Update â†’ Repeat: move centroids to minimize within-cluster variance.</p>
    <div class="usage-banner" role="note">ä½¿ç”¨å¼•å¯¼ / Quick Guideï¼šå…ˆé€‰æ‹©æ•°æ®é›†ä¸ç°‡æ•°ï¼Œç‚¹å‡»â€œè¿è¡Œâ€è§‚å¯Ÿç®—æ³•å¾ªç¯ï¼›éœ€è¦å­¦ä¹ å†…å®¹è¯·åˆ‡æ¢å³ä¾§æ ‡ç­¾é¡µï¼ˆæ¦‚å¿µ / æŒ‡æ ‡ / å°æµ‹ / å¤±æ•ˆåœºæ™¯ï¼‰ã€‚</div>
    <div class="responsive-note">ğŸ“± æ¨ªå±ä½“éªŒæ›´ä½³ Â· Landscape mode recommended for tablets.</div>
    <div class="top-controls" aria-label="top quick controls">
      <div class="control-block" aria-label="dataset selector">
        <label for="dataset-select">æ•°æ®é›† Dataset</label>
        <select id="dataset-select" aria-label="é€‰æ‹©æ•°æ®é›† Select dataset">
          <option value="blobs">é«˜æ–¯å›¢ Blobs</option>
          <option value="moons">åŒæœˆç‰™ Moons</option>
          <option value="circles">åŒå¿ƒç¯ Circles</option>
          <option value="grid">ç½‘æ ¼ Grid</option>
          <option value="custom">è‡ªå®šä¹‰ Custom</option>
        </select>
      </div>
      <div class="control-block" aria-label="cluster count">
        <label for="k-slider">ç°‡æ•° k</label>
        <input id="k-slider" type="range" min="1" max="10" value="3" aria-label="ç°‡æ•° K slider" />
        <input id="k-number" type="number" min="1" max="10" value="3" aria-label="ç°‡æ•° K æ•°å­—" />
      </div>
      <div class="control-block" aria-label="initialization method">
        <label for="init-select">åˆå§‹åŒ– Initialization</label>
        <select id="init-select" aria-label="é€‰æ‹©åˆå§‹åŒ–æ–¹å¼">
          <option value="random">éšæœº Random</option>
          <option value="kpp">k-means++</option>
          <option value="manual">æ‰‹åŠ¨ Manual</option>
        </select>
      </div>
      <div class="control-block" aria-label="run controls">
        <label>è¿è¡Œæ§åˆ¶ Run Controls</label>
        <div style="display:flex; gap:0.4rem; flex-wrap:wrap;">
          <button type="button" id="btn-run" class="icon-btn primary" aria-label="è¿è¡Œ Run">â–¶ Run</button>
          <button type="button" id="btn-pause" class="icon-btn" aria-label="æš‚åœ Pause">â¸ Pause</button>
          <button type="button" id="btn-step" class="icon-btn" aria-label="å•æ­¥ Step">â­ Step</button>
          <button type="button" id="btn-reset" class="icon-btn" aria-label="é‡ç½® Reset">â†º Reset</button>
        </div>
      </div>
      <div class="control-block" aria-label="seed control">
        <label for="seed-input">éšæœºç§å­ Seed</label>
        <div style="display:flex; gap:0.4rem;">
          <input id="seed-input" type="number" value="42" aria-label="éšæœºç§å­è¾“å…¥ Seed input" />
          <button type="button" id="btn-random-seed" class="icon-btn" aria-label="éšæœºéª°å­ Randomize">ğŸ²</button>
        </div>
      </div>
      <div class="control-block" aria-label="speed control">
        <label for="speed-range">åŠ¨ç”»é€Ÿåº¦ Speed</label>
        <input id="speed-range" type="range" min="0" max="100" value="60" aria-label="åŠ¨ç”»é€Ÿåº¦ slider" />
      </div>
      <div class="control-block" aria-label="help buttons">
        <label>å¸®åŠ© Help</label>
        <div style="display:flex; gap:0.4rem; flex-wrap:wrap;">
          <button type="button" class="icon-btn" aria-label="å¸®åŠ©è¯´æ˜ Help">â“ Help</button>
          <button type="button" class="icon-btn" aria-label="æ¢å¤é»˜è®¤ Reset defaults">ğŸ§¹ Reset Defaults</button>
        </div>
      </div>
    </div>
  </header>
  <main>
    <aside class="panel controls-panel" aria-label="è¯¦ç»†æ§åˆ¶é¢æ¿ Detailed controls">
      <section>
        <h2>å‚æ•°è°ƒèŠ‚ Parameters</h2>
        <div class="control-block">
          <label for="distance-select">è·ç¦» Distance</label>
          <select id="distance-select" aria-label="é€‰æ‹©è·ç¦»åº¦é‡">
            <option value="euclidean">æ¬§æ° Euclidean</option>
            <option value="manhattan">æ›¼å“ˆé¡¿ Manhattan</option>
          </select>
        </div>
        <div class="control-block">
          <label for="max-iter">æœ€å¤§è¿­ä»£ Max Iterations</label>
          <input id="max-iter" type="number" value="50" min="1" aria-label="æœ€å¤§è¿­ä»£æ¬¡æ•°" />
        </div>
        <div class="control-block">
          <label for="point-count">ç‚¹æ•°é‡ Point Count</label>
          <input id="point-count" type="number" value="600" min="10" max="3000" aria-label="ç‚¹æ•°é‡" />
        </div>
        <div class="control-block">
          <label for="noise-slider">å™ªå£° Noise Ratio</label>
          <input id="noise-slider" type="range" min="0" max="0.3" step="0.01" value="0.05" aria-label="å™ªå£°æ¯”ä¾‹" />
        </div>
        <fieldset style="border:1px solid var(--border-color); border-radius:12px; padding:0.8rem;">
          <legend>å¯é€‰è§†å›¾ Options</legend>
          <label><input type="checkbox" id="show-voronoi" /> æ˜¾ç¤º Voronoi / Show Voronoi</label><br />
          <label><input type="checkbox" id="show-trails" checked /> è´¨å¿ƒè½¨è¿¹ / Show Trails</label><br />
          <label><input type="checkbox" id="show-labels" /> æ ‡ç­¾ / Labels</label><br />
          <label><input type="checkbox" id="show-heat" /> çƒ­åŠ›èƒŒæ™¯ / Heatmap</label>
        </fieldset>
        <fieldset style="border:1px solid var(--border-color); border-radius:12px; padding:0.8rem;">
          <legend>æ•°æ®å¤„ç† Data Prep</legend>
          <label><input type="checkbox" id="toggle-standardize" /> æ ‡å‡†åŒ– / Standardize</label><br />
          <label><input type="checkbox" id="toggle-outliers" /> åŠ å…¥ç¦»ç¾¤ç‚¹ / Add Outliers</label>
        </fieldset>
      </section>
      <section>
        <h2>å¯¼å…¥å¯¼å‡º Import & Export</h2>
        <div class="control-block">
          <label for="csv-input">CSV æ•°æ®ç²˜è´´åŒº Paste CSV</label>
          <textarea id="csv-input" rows="6" aria-label="CSV è¾“å…¥åŒºåŸŸ"></textarea>
        </div>
        <div style="display:flex; gap:0.6rem; flex-wrap:wrap;">
          <button type="button" class="icon-btn" aria-label="å¯¼å…¥ CSV">â¬† Import</button>
          <button type="button" class="icon-btn" aria-label="å¯¼å‡º PNG">â¬‡ Export PNG</button>
          <button type="button" class="icon-btn" aria-label="å¯¼å‡ºå‚æ•° JSON">{} Export JSON</button>
        </div>
        <p class="hint-text" aria-live="polite">ç¤ºä¾‹ï¼šx,y\n1,2\n3,4</p>
      </section>
      <section>
        <h2>AB å¿«ç…§ AB Snapshots</h2>
        <div class="snapshot-grid" aria-label="å¿«ç…§åˆ—è¡¨">
          <div class="snapshot-placeholder" role="group" aria-label="å¿«ç…§æ§½ä½ snapshot slot">ç©º Empty</div>
          <div class="snapshot-placeholder" role="group" aria-label="å¿«ç…§æ§½ä½ snapshot slot">ç©º Empty</div>
          <div class="snapshot-placeholder" role="group" aria-label="å¿«ç…§æ§½ä½ snapshot slot">ç©º Empty</div>
        </div>
        <button type="button" class="icon-btn" aria-label="æ‹æ‘„å½“å‰çŠ¶æ€ Save snapshot">ğŸ“¸ Save Snapshot</button>
      </section>
    </aside>
    <section class="panel canvas-panel" aria-label="ä¸»å¯è§†åŒ–åŒºåŸŸ Main visualization">
      <div class="canvas-header" style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <h2 style="margin:0; font-size:1.3rem;">èšç±»ç”»å¸ƒ Cluster Canvas</h2>
          <p style="margin:0; font-size:0.9rem; color:var(--text-secondary);">æ‹–æ‹½è´¨å¿ƒã€è§‚å¯Ÿåˆ†é…ï¼›Drag centroids and inspect assignments.</p>
        </div>
        <div class="status-chips" style="display:flex; gap:0.4rem; flex-wrap:wrap;">
          <span class="chip" id="chip-status" aria-label="çŠ¶æ€">çŠ¶æ€ï¼šå¾…åˆå§‹åŒ– Â· Ready</span>
          <span class="chip" id="chip-converged" aria-label="æ”¶æ•›çŠ¶æ€">æ”¶æ•› Convergenceï¼š--</span>
        </div>
      </div>
      <div class="canvas-wrapper" role="presentation">
        <canvas id="cluster-canvas" width="900" height="600" aria-label="k-means å¯è§†åŒ–ç”»å¸ƒ"></canvas>
        <div class="canvas-overlay" id="canvas-overlay" aria-live="polite">å‡†å¤‡å°±ç»ªï¼šç”Ÿæˆæ•°æ®åç‚¹å‡»è¿è¡Œè§‚å¯Ÿèšç±»ã€‚Ready: generate data then press Run.</div>
      </div>
      <div class="metrics-bar" aria-label="å®æ—¶æŒ‡æ ‡">
        <div class="metric-card" role="status">
          <span>SSE æ€»å’Œ</span>
          <strong id="metric-sse">--</strong>
          <small>ç°‡å†…å¹³æ–¹å’Œ Sum of Squared Errors</small>
        </div>
        <div class="metric-card" role="status">
          <span>è½®å»“ç³»æ•° Silhouette</span>
          <strong id="metric-silhouette">--</strong>
          <small>æŠ½æ ·ä¼°è®¡ Sampled estimation</small>
        </div>
        <div class="metric-card" role="status">
          <span>è¿­ä»£ Iteration</span>
          <strong id="metric-iteration">0</strong>
          <small>æœ€å¤§è¿­ä»£é˜ˆå€¼ Max: 300</small>
        </div>
      </div>
      <div class="mini-charts" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px,1fr)); gap:0.8rem;">
        <div class="mini-chart" style="background:var(--tab-bg); border-radius:12px; padding:0.8rem;">
          <h3 style="margin:0 0 0.4rem; font-size:0.95rem;">æŸå¤±æ›²çº¿ Loss Curve</h3>
          <div class="chart-placeholder" style="height:120px; border:1px dashed var(--border-color); border-radius:10px; display:flex; align-items:center; justify-content:center; color:var(--text-secondary);">Mini Canvas</div>
        </div>
        <div class="mini-chart" style="background:var(--tab-bg); border-radius:12px; padding:0.8rem;">
          <h3 style="margin:0 0 0.4rem; font-size:0.95rem;">è‚˜éƒ¨æ³• Elbow</h3>
          <div class="chart-placeholder" style="height:120px; border:1px dashed var(--border-color); border-radius:10px; display:flex; align-items:center; justify-content:center; color:var(--text-secondary);">Mini Canvas</div>
        </div>
        <div class="mini-chart" style="background:var(--tab-bg); border-radius:12px; padding:0.8rem;">
          <h3 style="margin:0 0 0.4rem; font-size:0.95rem;">è½®å»“åˆ†å¸ƒ Silhouette</h3>
          <div class="chart-placeholder" style="height:120px; border:1px dashed var(--border-color); border-radius:10px; display:flex; align-items:center; justify-content:center; color:var(--text-secondary);">Mini Canvas</div>
        </div>
      </div>
    </section>
    <aside class="panel right-panel" aria-label="å­¦ä¹ ä¸ä¿¡æ¯é¢æ¿ Learning panel">
      <div class="tabs" role="tablist">
        <button class="active" role="tab" aria-selected="true" aria-controls="tab-concept" id="tab-btn-concept">æ¦‚å¿µ Concept</button>
        <button role="tab" aria-controls="tab-metrics" id="tab-btn-metrics">æŒ‡æ ‡ Metrics</button>
        <button role="tab" aria-controls="tab-quiz" id="tab-btn-quiz">å°æµ‹ Quiz</button>
        <button role="tab" aria-controls="tab-fail" id="tab-btn-fail">å¤±æ•ˆ Failure Cases</button>
      </div>
      <div class="tab-content">
        <div class="tab-pane active" id="tab-concept" role="tabpanel" aria-labelledby="tab-btn-concept">
          <section>
            <h3>ç®—æ³•æµç¨‹ Algorithm Loop</h3>
            <p>1. éšæœºåˆå§‹åŒ–è´¨å¿ƒã€‚2. å°†ç‚¹åˆ†é…åˆ°æœ€è¿‘è´¨å¿ƒã€‚3. æ›´æ–°è´¨å¿ƒä½ç½®ã€‚4. é‡å¤ç›´è‡³æ”¶æ•›ã€‚</p>
            <p>1. Initialize centroids. 2. Assign points to nearest centroid. 3. Update centroid mean. 4. Repeat until convergence.</p>
          </section>
          <section>
            <h3>é€‚ç”¨åœºæ™¯ Use Cases</h3>
            <ul>
              <li>ç°‡è¿‘ä¼¼çƒå½¢ã€‚Roughly spherical clusters.</li>
              <li>éœ€è¦å¿«é€ŸåŸå‹èšç±»ã€‚Rapid prototyping.</li>
            </ul>
          </section>
          <section>
            <h3>å±€é™æ€§ Limitations</h3>
            <ul>
              <li>å¯¹åˆå§‹å€¼æ•æ„Ÿã€‚Sensitive to initialization.</li>
              <li>ä¸é€‚åˆéå‡¸ç°‡ã€‚Not ideal for non-convex shapes.</li>
              <li>ç¦»ç¾¤ç‚¹å½±å“æ˜¾è‘—ã€‚Outliers can skew centroids.</li>
            </ul>
          </section>
        </div>
        <div class="tab-pane" id="tab-metrics" role="tabpanel" aria-labelledby="tab-btn-metrics">
          <section>
            <h3>SSE ç°‡å†…å¹³æ–¹å’Œ</h3>
            <p>åº¦é‡æ¯ä¸ªç°‡å†…æ ·æœ¬ä¸è´¨å¿ƒçš„å¹³æ–¹è·ç¦»ä¹‹å’Œã€‚å€¼è¶Šå°ï¼Œèšç±»è¶Šç´§å‡‘ã€‚Measures total squared distance of points to centroid within each cluster.</p>
          </section>
          <section>
            <h3>Silhouette è½®å»“ç³»æ•°</h3>
            <p>å•ç‚¹æŒ‡æ ‡ï¼š(b - a) / max(a, b)ã€‚a ä¸ºç°‡å†…å¹³å‡è·ç¦»ï¼Œb ä¸ºæœ€è¿‘å…¶ä»–ç°‡å¹³å‡è·ç¦»ã€‚Average silhouette æè¿°ç°‡æ˜¯å¦æ¸…æ™°ã€‚</p>
          </section>
          <section>
            <h3>è‚˜éƒ¨æ³• Elbow Method</h3>
            <p>ç»˜åˆ¶ä¸åŒ k çš„ SSEï¼Œå¯»æ‰¾ä¸‹é™å¹…åº¦è½¬æŠ˜ç‚¹ã€‚Plot SSE vs k to find point of diminishing returns.</p>
          </section>
        </div>
        <div class="tab-pane" id="tab-quiz" role="tabpanel" aria-labelledby="tab-btn-quiz">
          <section>
            <h3>çŸ¥è¯†å°æµ‹ Quiz</h3>
            <div class="quiz-question">
              <h4>Q1: è‚˜éƒ¨æ³•å»ºè®®çš„ k å€¼é€šå¸¸å¯¹åº”å“ªé‡Œï¼ŸWhere is elbow located?</h4>
              <div class="quiz-options" role="group" aria-label="é€‰é¡¹ Options">
                <label><input type="radio" name="quiz-q1" /> åœ¨ä¸‹é™æ›²çº¿çš„æ‹ç‚¹ At the elbow point.</label>
                <label><input type="radio" name="quiz-q1" /> æœ€å¤§çš„ k å€¼ Largest k.</label>
                <label><input type="radio" name="quiz-q1" /> æ›²çº¿èµ·ç‚¹ Curve start.</label>
              </div>
            </div>
            <div class="quiz-question">
              <h4>Q2: æ ‡å‡†åŒ–çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼ŸWhy standardize?</h4>
              <div class="quiz-options" role="group">
                <label><input type="radio" name="quiz-q2" /> æ¶ˆé™¤é‡çº²å½±å“ Remove scale bias.</label>
                <label><input type="radio" name="quiz-q2" /> å¢åŠ å™ªå£° Increase noise.</label>
                <label><input type="radio" name="quiz-q2" /> å‡å°‘æ ·æœ¬æ•°é‡ Reduce samples.</label>
              </div>
            </div>
            <div class="quiz-question">
              <h4>Q3: å¯¹â€œMoonsâ€æ•°æ®ï¼Œk-means è¡¨ç°å¦‚ä½•ï¼ŸHow does k-means perform on moons?</h4>
              <div class="quiz-options" role="group">
                <label><input type="radio" name="quiz-q3" /> æ•ˆæœè¾ƒå·®ï¼Œç°‡éå‡¸ Poor due to non-convex clusters.</label>
                <label><input type="radio" name="quiz-q3" /> éå¸¸å¥½ Very good.</label>
                <label><input type="radio" name="quiz-q3" /> æ— æ³•è¿è¡Œ Cannot run.</label>
              </div>
            </div>
            <div class="quiz-question">
              <h4>Q4: è½®å»“ç³»æ•°æ¥è¿‘ -1 è¡¨ç¤ºä»€ä¹ˆï¼ŸWhat does silhouette near -1 mean?</h4>
              <div class="quiz-options" role="group">
                <label><input type="radio" name="quiz-q4" /> æ ·æœ¬æ›´æ¥è¿‘å…¶ä»–ç°‡ Point closer to other cluster.</label>
                <label><input type="radio" name="quiz-q4" /> èšç±»å®Œç¾ Perfect clustering.</label>
                <label><input type="radio" name="quiz-q4" /> æ ·æœ¬å­¤ç«‹ Isolated point.</label>
              </div>
            </div>
            <button type="button" class="primary" aria-label="æäº¤æµ‹éªŒ Submit quiz">æäº¤ Submit</button>
            <button type="button" aria-label="é‡æ–°ä½œç­” Retake">é‡æ–°ä½œç­” Retake</button>
          </section>
        </div>
        <div class="tab-pane" id="tab-fail" role="tabpanel" aria-labelledby="tab-btn-fail">
          <section>
            <h3>ä½•æ—¶å¤±æ•ˆ When It Fails</h3>
            <ul>
              <li>éå‡¸æ•°æ®ï¼ˆå¦‚ Moonsï¼‰ã€‚Non-convex data (Moons).</li>
              <li>ç°‡å¯†åº¦å·®å¼‚å¤§ã€‚Different densities.</li>
              <li>ç¦»ç¾¤ç‚¹è¿‡å¤šã€‚Too many outliers.</li>
            </ul>
          </section>
          <section>
            <h3>å®è·µå»ºè®® Practical Tips</h3>
            <ul>
              <li>å°è¯•å¤šä¸ªéšæœºç§å­ã€‚Try multiple seeds.</li>
              <li>ç»“åˆé¢†åŸŸçŸ¥è¯†ã€‚Align with domain knowledge.</li>
            </ul>
          </section>
        </div>
      </div>
    </aside>
  </main>
  <section class="panel" style="margin:0 1.5rem 1.5rem;" aria-label="å­¦ä¹ æ€»ç»“åŒºåŸŸ Summary">
    <h2>å­¦ä¹ æ€»ç»“ Summary</h2>
    <p>ä¸€é”®ç”Ÿæˆå­¦ä¹ æ€»ç»“ï¼ˆåç»­é˜¶æ®µå®ç°ï¼‰ã€‚Generate learning summary (to be implemented in later phase).</p>
    <div style="display:flex; gap:0.6rem; flex-wrap:wrap;">
      <button type="button" class="icon-btn" aria-label="ç”Ÿæˆæ€»ç»“ Generate summary">ğŸ“ Generate Summary</button>
      <button type="button" class="icon-btn" aria-label="å¤åˆ¶æ€»ç»“ Copy summary">ğŸ“‹ Copy</button>
      <button type="button" class="icon-btn" aria-label="ä¸‹è½½æ€»ç»“ Download summary">ğŸ’¾ Download</button>
    </div>
    <textarea id="summary-output" rows="4" aria-label="æ€»ç»“è¾“å‡ºåŒºåŸŸ" placeholder="æ€»ç»“æ–‡æœ¬å°†åœ¨åç»­é˜¶æ®µç”Ÿæˆ..."></textarea>
  </section>
  <footer>
    <div class="footer-inner">
      <p>Â© 2025 K-Means Interactive Lesson Â· ä½œè€… Author: OpenAI åŠ©æ‰‹ Â· æ›´æ–°æ—¥æœŸ Updated: Phase 2</p>
      <p>é”®ç›˜å¿«æ·é”®ï¼šSpace è¿è¡Œ/æš‚åœ Â· S å•æ­¥ Â· R é‡ç½® Â· K èšç„¦ k æ»‘å— Â· H å¸®åŠ©ï¼ˆå³å°†åˆ°æ¥ï¼‰ã€‚Keyboard shortcuts coming soon.</p>
    </div>
  </footer>
</div>
<!-- ===== HTML Markup ===== -->
<!-- ===== App State & Utils ===== -->
<script>
  const KMeansApp = (() => {
    const state = {
      points: [],
      centroids: [],
      assignments: [],
      running: false,
      iteration: 0,
      converged: false,
      delay: 480,
      trails: [],
      manualAwait: 0,
      maxIterations: 300,
      dpr: window.devicePixelRatio || 1,
      rngSeed: 42,
      requestId: null,
      overlayTimeout: null,
    };

    const palette = [
      "#f94144",
      "#f3722c",
      "#f8961e",
      "#f9c74f",
      "#90be6d",
      "#43aa8b",
      "#577590",
      "#4d908e",
      "#277da1",
      "#9c89b8",
    ];

    const elements = {};

    function createMulberry32(seed) {
      let t = seed >>> 0;
      return () => {
        t += 0x6d2b79f5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    function cacheDom() {
      elements.canvas = document.getElementById("cluster-canvas");
      elements.overlay = document.getElementById("canvas-overlay");
      elements.ctx = elements.canvas.getContext("2d");
      elements.datasetSelect = document.getElementById("dataset-select");
      elements.kSlider = document.getElementById("k-slider");
      elements.kNumber = document.getElementById("k-number");
      elements.initSelect = document.getElementById("init-select");
      elements.distanceSelect = document.getElementById("distance-select");
      elements.maxIterInput = document.getElementById("max-iter");
      elements.pointCountInput = document.getElementById("point-count");
      elements.noiseSlider = document.getElementById("noise-slider");
      elements.seedInput = document.getElementById("seed-input");
      elements.speedRange = document.getElementById("speed-range");
      elements.showVoronoi = document.getElementById("show-voronoi");
      elements.showTrails = document.getElementById("show-trails");
      elements.showLabels = document.getElementById("show-labels");
      elements.showHeat = document.getElementById("show-heat");
      elements.toggleStandardize = document.getElementById("toggle-standardize");
      elements.toggleOutliers = document.getElementById("toggle-outliers");
      elements.metricSSE = document.getElementById("metric-sse");
      elements.metricSilhouette = document.getElementById("metric-silhouette");
      elements.metricIteration = document.getElementById("metric-iteration");
      elements.btnRun = document.getElementById("btn-run");
      elements.btnPause = document.getElementById("btn-pause");
      elements.btnStep = document.getElementById("btn-step");
      elements.btnReset = document.getElementById("btn-reset");
      elements.btnRandomSeed = document.getElementById("btn-random-seed");
      elements.chipStatus = document.getElementById("chip-status");
      elements.chipConverged = document.getElementById("chip-converged");
    }

    function linkRangeAndNumber(rangeEl, numberEl, onChange) {
      const sync = (value, source) => {
        const v = Math.min(parseInt(rangeEl.max, 10), Math.max(parseInt(rangeEl.min, 10), parseInt(value, 10)));
        if (source !== rangeEl) rangeEl.value = v;
        if (source !== numberEl) numberEl.value = v;
        if (typeof onChange === "function") onChange(v);
      };
      rangeEl.addEventListener("input", (e) => sync(e.target.value, rangeEl));
      numberEl.addEventListener("change", (e) => sync(e.target.value, numberEl));
    }

    function resizeCanvas() {
      const rect = elements.canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      if (!rect.width || !rect.height) return;
      elements.canvas.width = rect.width * dpr;
      elements.canvas.height = rect.height * dpr;
      state.canvasWidth = rect.width;
      state.canvasHeight = rect.height;
      state.dpr = dpr;
      elements.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      render();
    }

    function attachEvents() {
      window.addEventListener("resize", () => {
        clearTimeout(state.overlayTimeout);
        state.overlayTimeout = setTimeout(resizeCanvas, 200);
      });

      linkRangeAndNumber(elements.kSlider, elements.kNumber, () => {
        if (elements.initSelect.value !== "manual") {
          initializeCentroids();
          render();
        } else {
          prepareManualPlacement();
        }
        updateStatusChip();
      });

      elements.datasetSelect.addEventListener("change", () => {
        regenerateDataset();
      });

      elements.initSelect.addEventListener("change", () => {
        if (elements.initSelect.value === "manual") {
          prepareManualPlacement();
        } else {
          initializeCentroids();
          render();
        }
      });

      elements.distanceSelect.addEventListener("change", () => {
        render();
      });

      elements.maxIterInput.addEventListener("change", () => {
        state.maxIterations = Math.max(1, parseInt(elements.maxIterInput.value, 10) || 1);
      });

      elements.pointCountInput.addEventListener("change", () => regenerateDataset());
      elements.noiseSlider.addEventListener("input", () => regenerateDataset());
      elements.toggleStandardize.addEventListener("change", () => regenerateDataset());
      elements.toggleOutliers.addEventListener("change", () => regenerateDataset());

      elements.btnRun.addEventListener("click", () => setRunning(true));
      elements.btnPause.addEventListener("click", () => setRunning(false));
      elements.btnStep.addEventListener("click", () => {
        if (!ensureCentroidsReady()) return;
        performIteration();
        render();
      });
      elements.btnReset.addEventListener("click", () => regenerateDataset());
      elements.btnRandomSeed.addEventListener("click", () => {
        const newSeed = Math.floor(Math.random() * 100000);
        elements.seedInput.value = newSeed;
        state.rngSeed = newSeed;
        regenerateDataset();
      });

      elements.seedInput.addEventListener("change", () => {
        const seedValue = parseInt(elements.seedInput.value, 10);
        if (!Number.isFinite(seedValue)) {
          elements.seedInput.value = state.rngSeed;
          return;
        }
        state.rngSeed = seedValue;
        regenerateDataset();
      });

      elements.speedRange.addEventListener("input", () => {
        const value = parseInt(elements.speedRange.value, 10);
        state.delay = 700 - Math.min(650, value * 6.2);
      });

      elements.showVoronoi.addEventListener("change", () => render());
      elements.showTrails.addEventListener("change", () => render());
      elements.showLabels.addEventListener("change", () => render());
      elements.showHeat.addEventListener("change", () => render());

      elements.canvas.addEventListener("click", (event) => {
        if (elements.initSelect.value !== "manual") return;
        if (!state.points.length) return;
        const rect = elements.canvas.getBoundingClientRect();
        const nx = (event.clientX - rect.left) / rect.width;
        const ny = (event.clientY - rect.top) / rect.height;
        if (state.centroids.length < getK()) {
          state.centroids.push({ x: nx, y: ny, trail: [] });
          state.trails.push([{ x: nx, y: ny }]);
          state.manualAwait = getK() - state.centroids.length;
          updateOverlay();
          render();
        }
        if (state.centroids.length === getK()) {
          elements.overlay.dataset.manual = "done";
          setOverlayText("è´¨å¿ƒå·²æ”¾ç½®ï¼Œå¯è¿è¡Œç®—æ³•ã€‚Centroids placed, press Run.");
        }
      });

      document.addEventListener("keydown", (event) => {
        if (event.target && ["INPUT", "TEXTAREA"].includes(event.target.tagName)) return;
        switch (event.key.toLowerCase()) {
          case " ":
            event.preventDefault();
            setRunning(!state.running);
            break;
          case "s":
            event.preventDefault();
            setRunning(false);
            performIteration();
            render();
            break;
          case "r":
            event.preventDefault();
            regenerateDataset();
            break;
          case "k":
            event.preventDefault();
            elements.kSlider.focus();
            break;
          default:
            break;
        }
      });
    }

    function getK() {
      return Math.max(1, parseInt(elements.kSlider.value, 10) || 1);
    }

    function regenerateDataset() {
      setRunning(false);
      const datasetType = elements.datasetSelect.value;
      const count = Math.max(10, parseInt(elements.pointCountInput.value, 10) || 300);
      const noise = parseFloat(elements.noiseSlider.value) || 0;
      const rng = createMulberry32(state.rngSeed);
      let points = [];
      if (datasetType === "blobs") points = generateBlobs(count, noise, rng);
      else if (datasetType === "circles") points = generateCircles(count, noise, rng);
      else if (datasetType === "moons") points = generateMoons(count, noise, rng);
      else if (datasetType === "grid") points = generateGrid(count, noise, rng);
      else points = generateCustom(count, noise, rng);

      if (elements.toggleStandardize.checked) {
        points = standardizePoints(points);
      } else {
        points = normalizePoints(points);
      }

      if (elements.toggleOutliers.checked) {
        const outliers = Math.max(1, Math.floor(points.length * 0.05));
        for (let i = 0; i < outliers; i += 1) {
          points.push({
            x: rng() * 1.4 - 0.2,
            y: rng() * 1.4 - 0.2,
          });
        }
      }

      state.points = points.map((p) => ({ x: p.x, y: p.y }));
      state.assignments = new Array(state.points.length).fill(-1);
      state.iteration = 0;
      state.converged = false;
      state.trails = [];
      elements.metricIteration.textContent = "0";
      elements.metricSSE.textContent = "--";
      elements.metricSilhouette.textContent = "--";
      elements.chipConverged.textContent = "æ”¶æ•› Convergenceï¼š--";
      updateStatusChip();
      updateOverlay();
      initializeCentroids();
      render();
    }

    function standardizePoints(points) {
      if (!points.length) return points;
      const mean = points.reduce(
        (acc, p) => {
          acc.x += p.x;
          acc.y += p.y;
          return acc;
        },
        { x: 0, y: 0 }
      );
      mean.x /= points.length;
      mean.y /= points.length;
      let sumSqX = 0;
      let sumSqY = 0;
      points.forEach((p) => {
        sumSqX += (p.x - mean.x) ** 2;
        sumSqY += (p.y - mean.y) ** 2;
      });
      const stdX = Math.sqrt(sumSqX / points.length) || 1;
      const stdY = Math.sqrt(sumSqY / points.length) || 1;
      const standardized = points.map((p) => ({
        x: (p.x - mean.x) / stdX,
        y: (p.y - mean.y) / stdY,
      }));
      return normalizePoints(standardized);
    }

    function normalizePoints(points) {
      if (!points.length) return points;
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      points.forEach((p) => {
        if (p.x < minX) minX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.x > maxX) maxX = p.x;
        if (p.y > maxY) maxY = p.y;
      });
      const spanX = maxX - minX || 1;
      const spanY = maxY - minY || 1;
      return points.map((p) => ({
        x: (p.x - minX) / spanX,
        y: (p.y - minY) / spanY,
      }));
    }

    function initializeCentroids() {
      state.centroids = [];
      state.trails = [];
      state.manualAwait = 0;
      const k = getK();
      if (!state.points.length) return;
      if (elements.initSelect.value === "manual") {
        prepareManualPlacement();
        render();
        return;
      }
      const rng = createMulberry32(state.rngSeed + 99);
      if (elements.initSelect.value === "kpp" && state.points.length) {
        const chosen = [];
        const distances = new Array(state.points.length).fill(Infinity);
        chosen.push(randomPoint(rng));
        for (let c = 1; c < k; c += 1) {
          for (let i = 0; i < state.points.length; i += 1) {
            const d = euclideanDistance(state.points[i], chosen[c - 1]);
            if (d < distances[i]) distances[i] = d;
          }
          const sum = distances.reduce((acc, val) => acc + val, 0);
          let threshold = rng() * sum;
          let nextIndex = 0;
          for (let i = 0; i < distances.length; i += 1) {
            threshold -= distances[i];
            if (threshold <= 0) {
              nextIndex = i;
              break;
            }
          }
          chosen.push({ ...state.points[nextIndex] });
        }
        state.centroids = chosen.map((p) => ({ x: p.x, y: p.y, trail: [] }));
      } else {
        const used = new Set();
        while (state.centroids.length < k) {
          const idx = Math.floor(rng() * state.points.length);
          if (used.has(idx)) continue;
          used.add(idx);
          const point = state.points[idx];
          state.centroids.push({ x: point.x, y: point.y, trail: [] });
        }
      }
      state.trails = state.centroids.map((c) => [{ x: c.x, y: c.y }]);
      updateOverlay();
    }

    function randomPoint(rng) {
      const idx = Math.floor(rng() * state.points.length);
      return { ...state.points[idx] };
    }

    function prepareManualPlacement() {
      state.centroids = [];
      state.trails = [];
      state.manualAwait = getK();
      setRunning(false);
      setOverlayText(`æ‰‹åŠ¨æ”¾ç½®è´¨å¿ƒï¼šéœ€é€‰æ‹© ${state.manualAwait} ä¸ªç‚¹ä½ã€‚Click ${state.manualAwait} times to place centroids.`);
    }

    function ensureCentroidsReady() {
      if (!state.points.length) return false;
      if (state.centroids.length === getK()) return true;
      if (elements.initSelect.value === "manual") {
        setOverlayText("è¯·å…ˆåœ¨ç”»å¸ƒä¸Šæ”¾ç½®å…¨éƒ¨è´¨å¿ƒã€‚Place all centroids before running.");
        return false;
      }
      initializeCentroids();
      return state.centroids.length === getK();
    }

    function setRunning(running) {
      if (running && !ensureCentroidsReady()) return;
      state.running = running;
      if (running) {
        state.lastTimestamp = 0;
        loop(performance.now());
        setOverlayText("è¿è¡Œä¸­â€¦ç‚¹å‡»æš‚åœå¯åœæ­¢ã€‚Runningâ€¦ press Pause to stop.", 2000);
      } else if (state.requestId) {
        cancelAnimationFrame(state.requestId);
        state.requestId = null;
      }
      updateStatusChip();
      updateOverlay();
      render();
    }

    function loop(timestamp) {
      if (!state.running) return;
      if (!state.lastTimestamp) state.lastTimestamp = timestamp;
      const elapsed = timestamp - state.lastTimestamp;
      if (elapsed >= state.delay) {
        state.lastTimestamp = timestamp;
        performIteration();
      }
      render();
      state.requestId = requestAnimationFrame(loop);
    }

    function performIteration() {
      if (!state.points.length || !state.centroids.length) return;
      state.iteration += 1;
      const assignments = [];
      const counts = Array(state.centroids.length).fill(0);
      const sums = Array(state.centroids.length)
        .fill(0)
        .map(() => ({ x: 0, y: 0 }));
      for (let i = 0; i < state.points.length; i += 1) {
        const point = state.points[i];
        let bestDist = Infinity;
        let bestIdx = 0;
        for (let c = 0; c < state.centroids.length; c += 1) {
          const dist = distance(point, state.centroids[c]);
          if (dist < bestDist) {
            bestDist = dist;
            bestIdx = c;
          }
        }
        assignments[i] = bestIdx;
        counts[bestIdx] += 1;
        sums[bestIdx].x += point.x;
        sums[bestIdx].y += point.y;
      }

      handleEmptyClusters(counts, assignments, sums);

      const epsilon = 1e-4;
      let maxShift = 0;
      for (let c = 0; c < state.centroids.length; c += 1) {
        const centroid = state.centroids[c];
        const count = counts[c];
        if (count === 0) continue;
        const newX = sums[c].x / count;
        const newY = sums[c].y / count;
        const shift = Math.sqrt((centroid.x - newX) ** 2 + (centroid.y - newY) ** 2);
        if (elements.showTrails.checked) {
          const trail = state.trails[c];
          trail.push({ x: newX, y: newY });
          if (trail.length > 50) trail.shift();
        }
        centroid.x = newX;
        centroid.y = newY;
        if (shift > maxShift) maxShift = shift;
      }

      state.assignments = assignments;
      const sse = computeSSE(assignments);
      const silhouette = computeSilhouette(assignments);
      state.converged = maxShift < epsilon || state.iteration >= state.maxIterations;
      if (state.converged) {
        setRunning(false);
        elements.chipConverged.textContent = `æ”¶æ•› Convergenceï¼š${maxShift < epsilon ? "æ˜¯ Yes" : "è¾¾åˆ°é˜ˆå€¼ Max"}`;
      }
      elements.metricIteration.textContent = state.iteration.toString();
      elements.metricSSE.textContent = sse.toFixed(2);
      elements.metricSilhouette.textContent = Number.isFinite(silhouette)
        ? silhouette.toFixed(3)
        : "--";
      updateStatusChip();
    }

    function handleEmptyClusters(counts, assignments, sums) {
      const epsilon = 1e-6;
      for (let c = 0; c < counts.length; c += 1) {
        if (counts[c] > 0) continue;
        let farthestIdx = -1;
        let farthestDist = -Infinity;
        for (let i = 0; i < state.points.length; i += 1) {
          const minDist = state.centroids.reduce((min, centroid, idx) => {
            if (idx === c) return min;
            const d = distance(state.points[i], centroid);
            return d < min ? d : min;
          }, Infinity);
          if (minDist > farthestDist + epsilon) {
            farthestDist = minDist;
            farthestIdx = i;
          }
        }
        if (farthestIdx === -1) continue;
        const point = state.points[farthestIdx];
        const prev = assignments[farthestIdx];
        if (prev >= 0 && prev !== c) {
          counts[prev] = Math.max(0, counts[prev] - 1);
          sums[prev].x -= point.x;
          sums[prev].y -= point.y;
        }
        state.centroids[c].x = point.x;
        state.centroids[c].y = point.y;
        state.trails[c] = [{ x: point.x, y: point.y }];
        assignments[farthestIdx] = c;
        counts[c] = 1;
        sums[c].x = point.x;
        sums[c].y = point.y;
        c = -1; // restart to ensure cascading empties handled
      }
    }

    function computeSSE(assignments) {
      let total = 0;
      for (let i = 0; i < state.points.length; i += 1) {
        const clusterIdx = assignments[i];
        if (clusterIdx < 0) continue;
        const centroid = state.centroids[clusterIdx];
        total += euclideanDistance(state.points[i], centroid) ** 2;
      }
      return total;
    }

    function computeSilhouette(assignments) {
      const n = state.points.length;
      if (!n || state.centroids.length < 2) return NaN;
      const clusters = Array.from({ length: state.centroids.length }, () => []);
      for (let i = 0; i < n; i += 1) {
        const clusterIdx = assignments[i];
        if (clusterIdx >= 0) clusters[clusterIdx].push(i);
      }
      const sampleSize = Math.min(300, n);
      const rng = createMulberry32(state.rngSeed + state.iteration + 7);
      let sumSilhouette = 0;
      for (let s = 0; s < sampleSize; s += 1) {
        const idx = Math.floor(rng() * n);
        const clusterIdx = assignments[idx];
        if (clusterIdx < 0) continue;
        const ownCluster = clusters[clusterIdx];
        const point = state.points[idx];
        let a = 0;
        if (ownCluster.length > 1) {
          let total = 0;
          for (let j = 0; j < ownCluster.length; j += 1) {
            const otherIdx = ownCluster[j];
            if (otherIdx === idx) continue;
            total += euclideanDistance(point, state.points[otherIdx]);
          }
          a = total / Math.max(1, ownCluster.length - 1);
        }
        let b = Infinity;
        for (let c = 0; c < clusters.length; c += 1) {
          if (c === clusterIdx || clusters[c].length === 0) continue;
          let total = 0;
          for (let j = 0; j < clusters[c].length; j += 1) {
            total += euclideanDistance(point, state.points[clusters[c][j]]);
          }
          const avg = total / clusters[c].length;
          if (avg < b) b = avg;
        }
        if (!Number.isFinite(b)) continue;
        const denom = Math.max(a, b);
        const sVal = denom === 0 ? 0 : (b - a) / denom;
        sumSilhouette += sVal;
      }
      return sumSilhouette / sampleSize;
    }

    function distance(a, b) {
      return elements.distanceSelect.value === "manhattan"
        ? Math.abs(a.x - b.x) + Math.abs(a.y - b.y)
        : Math.hypot(a.x - b.x, a.y - b.y);
    }

    function euclideanDistance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function updateStatusChip() {
      elements.chipStatus.textContent = `çŠ¶æ€ Statusï¼š${state.running ? "è¿è¡Œä¸­ Running" : "å·²å°±ç»ª Ready"}`;
    }

    function setOverlayText(text, timeout = 0) {
      if (!elements.overlay) return;
      elements.overlay.textContent = text;
      elements.overlay.style.opacity = 1;
      if (timeout > 0) {
        clearTimeout(state.overlayTimeout);
        state.overlayTimeout = setTimeout(() => {
          elements.overlay.style.opacity = 0;
        }, timeout);
      }
    }

    function updateOverlay() {
      if (!elements.overlay) return;
      if (!state.points.length) {
        setOverlayText("æœªç”Ÿæˆæ•°æ®ã€‚æ£€æŸ¥è®¾ç½®åé‡è¯•ã€‚No dataset yet, adjust parameters.");
        return;
      }
      if (elements.initSelect.value === "manual") {
        if (state.centroids.length < getK()) {
          setOverlayText(`æ‰‹åŠ¨æ”¾ç½®è´¨å¿ƒï¼šå‰©ä½™ ${getK() - state.centroids.length} ä¸ªã€‚Place ${
            getK() - state.centroids.length
          } centroids.`);
        } else {
          setOverlayText("è´¨å¿ƒå·²æ”¾ç½®ï¼Œå¯è¿è¡Œç®—æ³•ã€‚Centroids ready.", 2000);
        }
      } else if (state.running) {
        setOverlayText("è¿è¡Œä¸­â€¦ Runningâ€¦", 0);
      } else {
        setOverlayText("ç‚¹å‡»è¿è¡Œæˆ–å•æ­¥æŸ¥çœ‹èšç±»è¿‡ç¨‹ã€‚Press Run or Step to iterate.", 2200);
      }
    }

    function render() {
      if (!elements.ctx || !state.canvasWidth || !state.canvasHeight) return;
      const ctx = elements.ctx;
      ctx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
      if (elements.showHeat.checked && state.centroids.length) drawHeatmap(ctx);
      if (elements.showVoronoi.checked && state.centroids.length) drawVoronoi(ctx);
      drawPoints(ctx);
      if (elements.showTrails.checked) drawTrails(ctx);
      drawCentroids(ctx);
    }

    function drawPoints(ctx) {
      const radius = Math.max(2, Math.min(state.canvasWidth, state.canvasHeight) * 0.007);
      ctx.save();
      ctx.lineWidth = 0;
      for (let i = 0; i < state.points.length; i += 1) {
        const p = state.points[i];
        const assignment = state.assignments[i];
        const color = assignment >= 0 ? palette[assignment % palette.length] : "#666";
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p.x * state.canvasWidth, p.y * state.canvasHeight, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawCentroids(ctx) {
      const size = Math.max(8, Math.min(state.canvasWidth, state.canvasHeight) * 0.02);
      ctx.save();
      ctx.lineWidth = 2;
      for (let i = 0; i < state.centroids.length; i += 1) {
        const centroid = state.centroids[i];
        const color = palette[i % palette.length];
        const x = centroid.x * state.canvasWidth;
        const y = centroid.y * state.canvasHeight;
        ctx.fillStyle = color;
        ctx.strokeStyle = "#1f2933";
        ctx.beginPath();
        ctx.moveTo(x, y - size);
        ctx.lineTo(x + size * 0.7, y + size * 0.7);
        ctx.lineTo(x - size * 0.7, y + size * 0.7);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        if (elements.showLabels.checked) {
          ctx.font = "14px/1.2 \"Segoe UI\", sans-serif";
          ctx.fillStyle = "#1e1e2f";
          ctx.fillText(`C${i + 1}`, x + size * 0.8, y - size * 0.6);
        }
      }
      ctx.restore();
    }

    function drawTrails(ctx) {
      ctx.save();
      ctx.lineWidth = 1.6;
      ctx.setLineDash([4, 4]);
      for (let i = 0; i < state.trails.length; i += 1) {
        const trail = state.trails[i];
        if (!trail || trail.length < 2) continue;
        const color = palette[i % palette.length];
        ctx.strokeStyle = color;
        ctx.beginPath();
        for (let t = 0; t < trail.length; t += 1) {
          const pos = trail[t];
          const px = pos.x * state.canvasWidth;
          const py = pos.y * state.canvasHeight;
          if (t === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      ctx.restore();
      ctx.setLineDash([]);
    }

    function drawVoronoi(ctx) {
      const step = 24;
      const width = state.canvasWidth;
      const height = state.canvasHeight;
      for (let y = 0; y <= height; y += step) {
        for (let x = 0; x <= width; x += step) {
          let bestIdx = 0;
          let bestDist = Infinity;
          const point = { x: x / width, y: y / height };
          for (let c = 0; c < state.centroids.length; c += 1) {
            const dist = distance(point, state.centroids[c]);
            if (dist < bestDist) {
              bestDist = dist;
              bestIdx = c;
            }
          }
          ctx.fillStyle = `${palette[bestIdx % palette.length]}20`;
          ctx.fillRect(x - step / 2, y - step / 2, step, step);
        }
      }
    }

    function drawHeatmap(ctx) {
      const step = 18;
      const width = state.canvasWidth;
      const height = state.canvasHeight;
      for (let y = 0; y <= height; y += step) {
        for (let x = 0; x <= width; x += step) {
          const point = { x: x / width, y: y / height };
          let minDist = Infinity;
          for (let c = 0; c < state.centroids.length; c += 1) {
            const dist = distance(point, state.centroids[c]);
            if (dist < minDist) minDist = dist;
          }
          const alpha = Math.max(0, 1 - minDist * 1.5);
          ctx.fillStyle = `rgba(76, 110, 245, ${alpha * 0.25})`;
          ctx.fillRect(x - step / 2, y - step / 2, step, step);
        }
      }
    }

    function generateBlobs(count, noise, rng) {
      const centers = [
        { x: 0.3, y: 0.3 },
        { x: 0.7, y: 0.35 },
        { x: 0.45, y: 0.75 },
        { x: 0.75, y: 0.7 },
      ];
      const points = [];
      for (let i = 0; i < count; i += 1) {
        const c = centers[Math.floor(rng() * centers.length)];
        const spread = 0.12 + noise * 0.4;
        points.push({
          x: c.x + (rng() - 0.5) * spread,
          y: c.y + (rng() - 0.5) * spread,
        });
      }
      return points;
    }

    function generateCircles(count, noise, rng) {
      const points = [];
      for (let i = 0; i < count; i += 1) {
        const outer = i % 2 === 0;
        const radius = outer ? 0.38 : 0.2;
        const angle = rng() * Math.PI * 2;
        const jitter = noise * 0.3;
        const r = radius + (rng() - 0.5) * jitter;
        points.push({
          x: 0.5 + Math.cos(angle) * r,
          y: 0.5 + Math.sin(angle) * r,
        });
      }
      return points;
    }

    function generateMoons(count, noise, rng) {
      const points = [];
      const half = Math.floor(count / 2);
      for (let i = 0; i < half; i += 1) {
        const angle = Math.PI * (i / half) + rng() * noise * 1.2;
        points.push({
          x: 0.25 + Math.cos(angle) * 0.3 + rng() * noise * 0.3,
          y: 0.45 + Math.sin(angle) * 0.2 + rng() * noise * 0.3,
        });
      }
      for (let i = 0; i < count - half; i += 1) {
        const angle = Math.PI * (i / half) + rng() * noise * 1.2;
        points.push({
          x: 0.55 + Math.cos(Math.PI - angle) * 0.3 + rng() * noise * 0.3,
          y: 0.55 - Math.sin(Math.PI - angle) * 0.2 + rng() * noise * 0.3,
        });
      }
      return points;
    }

    function generateGrid(count, noise, rng) {
      const size = Math.max(2, Math.floor(Math.sqrt(count)));
      const points = [];
      for (let i = 0; i < size; i += 1) {
        for (let j = 0; j < size; j += 1) {
          points.push({
            x: (i + 0.5 + (rng() - 0.5) * noise) / size,
            y: (j + 0.5 + (rng() - 0.5) * noise) / size,
          });
        }
      }
      while (points.length > count) points.pop();
      return points;
    }

    function generateCustom(count, noise, rng) {
      const points = [];
      for (let i = 0; i < count; i += 1) {
        points.push({ x: rng(), y: rng() });
      }
      if (noise > 0.01) {
        const extra = Math.floor(count * noise * 0.5);
        for (let i = 0; i < extra; i += 1) {
          points.push({ x: rng(), y: rng() });
        }
      }
      return points;
    }

    function init() {
      cacheDom();
      attachEvents();
      state.maxIterations = parseInt(elements.maxIterInput.value, 10) || 300;
      state.delay = 700 - Math.min(650, parseInt(elements.speedRange.value, 10) * 6.2 || 0);
      state.rngSeed = parseInt(elements.seedInput.value, 10) || 42;
      resizeCanvas();
      regenerateDataset();
      console.info("K-Means Lab Phase 2 ready.");
    }

    return { init };
  })();

  document.addEventListener("DOMContentLoaded", () => {
    KMeansApp.init();
  });
</script>
</body>
</html>
